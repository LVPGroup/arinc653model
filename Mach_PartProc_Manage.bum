<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.machineFile org.eventb.core.comment="* ***************************************************&#10;The Event-B model of a verified partitioning kernel for safety-critical realtime systems&#10;Created by Yongwang Zhao ( zhaoyongwang@gmail.com)&#10;National Key Laboratory of Software Development Environment (NLSDE)&#10;School of Computer and Engineering, Beihang University, Beijing, China&#10;Date: 05/2014&#10;**************************************************/&#10;this refinement defines the behavior of OPERATIONS according to ARINC653" org.eventb.core.configuration="org.eventb.core.fwd;de.prob.units.mchBase;org.eventb.codegen.ui.cgConfig" org.eventb.texttools.text_lastmodified="1409955677967" org.eventb.texttools.text_representation="machine Mach_PartProc_Manage&#10;//* ***************************************************&#10;//   The Event-B model of a verified partitioning kernel for safety-critical realtime systems&#10;//   Created by Yongwang Zhao ( zhaoyongwang@gmail.com)&#10;//   National Key Laboratory of Software Development Environment (NLSDE)&#10;//   School of Computer and Engineering, Beihang University, Beijing, China&#10;//&#10;&#10;//   Date: 05/2014&#10;//   **************************************************/&#10;// this refinement defines the behavior of OPERATIONS according to ARINC653&#10;&#10; refines Mach_PartProc_Trans_with_Events  sees Ctx_PartProc_Manage&#10;&#10;variables processes processes_of_partition partition_mode process_state periodtype_of_process&#10;&#10;&#9;&#9;  //process_ids //all created processes which have the ID. error handler does not has ID&#10;          process_wait_type // mainproc_of_partition // the only one main proc of each partition&#10;          locklevel_of_partition&#10;          /* denotes the current lock level of the partition&#10;             preemption_of_partitions */&#10;          startcondition_of_partition&#10;          /* denotes the reason the partition is started&#10;             schedulable_of_partition //the scheduling of a partition is activated or disactivated? */&#10;          basepriority_of_process // Denotes the capability of the process to manipulate other processes.&#10;          period_of_process // Identifies the period of activation for a periodic process. A distinct and unique value should be specified to designate the process as aperiodic&#10;          timecapacity_of_process // Defines the elapsed time within which the process should complete its execution.&#10;          deadline_of_process // Specifies the type of deadline relating to the process, and may be “hard” or “soft”.&#10;          currentpriority_of_process // Defines the priority with which the process may access and receive resources. It is set to base priority at initialization time and is dynamic at runtime.&#10;          deadlinetime_of_process // The deadline time is periodically evaluated by the operating system to determine whether the process is satisfactorily completing its processing within the allotted time.&#10;          releasepoint_of_process&#10;          /* the release point of processes&#10;             nextreleasepoint_of_process // the next release point of processes */&#10;          delaytime_of_process // if the proc is delayed started, the delaytime should be saved(used when parttion START --&gt; NORMAL)&#10;          current_partition // the partition in which a thread is now running. at each time, only one thread is running&#10;          current_process&#10;          current_partition_flag // true:indicate that the current_partition is valid, false: indicate NULL (unavailable)&#10;          current_process_flag // same as current partition flag&#10;          clock_tick // system clock ticks&#10;          need_reschedule // indicate the flag to reschedule after some events, for example suspend a thread&#10;          need_procresch //after partition scheduling, trigger the process level scheduling&#10;          preempter_of_partition // the process who execute the lock_preemption (increase the locklevel and disable scheduling), at most one preempter proc in a partition&#10;          timeout_trigger // all processes waiting for resources with a timeout, will be triggered after the timeout ellapsed.&#10;          errorhandler_of_partition // each partition has one error handler at most. other error handler can be created only after the previous handler is finished&#10;          process_call_errorhandler // error handler is created by a process, then the process is preempted by the error handler&#10;&#10;&#10;invariants&#10;  @inv_process_wait_type process_wait_type ∈ processes ⇸ PROCESS_WAIT_TYPES // partial function, only if the process is in WAITING&#10;&#10;&#10;  @inv_proc_waittype2 ∀p·(p∈processes ∧ (process_state(p)=PS_Waiting ∨ process_state(p)=PS_WaitandSuspend)⇒p∈dom(process_wait_type))&#10;  @inv_locklevel locklevel_of_partition ∈ PARTITIONS → ℕ&#10;  @inv_start_condition startcondition_of_partition ∈ PARTITIONS ⇸ PARTITION_STARTCONDITIONS&#10;  @inv_start_imply_locklevel ∀p·(p∈PARTITIONS∧(partition_mode(p)=PM_COLD_START ∨ partition_mode(p)=PM_WARM_START) ⇒locklevel_of_partition(p)&gt;0)&#10;  @inv_locklevel0_imply_normal ∀p·(p∈PARTITIONS ∧ locklevel_of_partition(p)=0 ⇒ partition_mode(p)=PM_NORMAL)&#10;&#10;//we do not consider the time&#10;//  @inv_partperiod_greatest_common_factor_procperiod&#10;// ∀p·(p∈processes ∧ period_of_process(p) ≠INFINITE_TIME_VALUE ⇒  (∃n·(n∈ℕ1 ∧ Period_of_Partition(processes_of_partition(p))∗n=period_of_process(p)))) // the partition period is the greatest common factor （最大公因数）of the process periods within a partition&#10;//  @inv_timcap_lessthen_period ∀p·(p∈processes ∧ period_of_process(p) ≠INFINITE_TIME_VALUE ⇒ timecapacity_of_process(p) &lt; period_of_process(p))&#10;&#10;  @inv_basepriority_processes basepriority_of_process ∈ processes → MIN_PRIORITY_VALUE‥MAX_PRIORITY_VALUE&#10;  @inv_period_processes period_of_process ∈ processes → ℤ // infinite(-1) means aperiodic&#10;  @inv_timecapacity_processes timecapacity_of_process ∈ processes → ℤ // infinite(-1) means no deadline time&#10;  @inv_deadline_processes deadline_of_process ∈ processes → DEADLINE_TYPE&#10;  @inv_currentpriority_processes currentpriority_of_process ∈ processes → MIN_PRIORITY_VALUE‥MAX_PRIORITY_VALUE&#10;  @inv_deadlinetime_processes deadlinetime_of_process ∈ processes ⇸ ℕ&#10;  @inv_releasepoint_of_process releasepoint_of_process ∈ processes ⇸ ℕ // @inv_nextreleasepoint_of_process nextreleasepoint_of_process ∈ processes ⇸ ℕ&#10;  @inv_delaytime_of_process delaytime_of_process ∈ processes ⇸ ℕ&#10;  @inv_delaytime2 ∀p·(p∈processes ∧ partition_mode(processes_of_partition(p))=PM_NORMAL ∧ process_state(p)=PS_Waiting ∧ process_wait_type(p)=PROC_WAIT_DELAY ⇒ p∈dom(delaytime_of_process) )&#10;  @inv_periodtype1 ∀p·(p∈processes ⇒(periodtype_of_process(p)=APERIOD_PROC⇔ period_of_process(p)=INFINITE_TIME_VALUE))&#10;  @inv_periodtype2 ∀p·(p∈processes ⇒(periodtype_of_process(p)=PERIOD_PROC⇔ period_of_process(p)≠INFINITE_TIME_VALUE))&#10;  /* partial func. if the process was delayed started, the &lt;process--&gt;delaytime&gt; is in this var&#10;     @inv_remain_timecapacity_threads remain_timecapacity_of_process ∈ processes → ℕ&#10;     @inv_wakeuptime_threads wakeuptime_of_process ∈ processes → ℕ&#10;     @inv_system_started system_has_inited ∈ BOOL */&#10;  @inv_curpart current_partition ∈ PARTITIONS&#10;  @inv_curpart_flag current_partition_flag ∈ BOOL&#10;  @inv_curproc_flag current_process_flag ∈ BOOL&#10;  @inv_curproc (current_process_flag = TRUE ⇒  current_process ∈ processes)&#10;  @inv_curprocimplycurpart current_process_flag = TRUE ⇒ current_partition_flag = TRUE&#10;  @inv_cur_proc_part (current_process_flag = TRUE ∧ current_partition_flag = TRUE ⇒ processes_of_partition(current_process) = current_partition)&#10;  @inv_partstate_curr (current_partition_flag = TRUE ⇒ partition_mode(current_partition) ≠ PM_IDLE)&#10;  @inv_procstate_curr (current_process_flag = TRUE ⇒ process_state(current_process) = PS_Running ∧ partition_mode(current_partition)=PM_NORMAL)&#10;  /* @glue_proc_states_dormant ∀proc·(proc∈processes ⇒ (process_state_r(proc) = PS_Dormant ⇔ process_state(proc) = TS_Dormant ))&#10;     @glue_proc_states_ready ∀proc·(proc∈processes ⇒ (process_state_r(proc) = PS_Ready ⇔ process_state(proc) = TS_Ready ))&#10;     @glue_proc_states_running ∀proc·(proc∈processes ⇒ (process_state_r(proc) = PS_Running ⇔ process_state(proc) = TS_Running))&#10;     @glue_proc_states_waiting ∀proc·(proc∈processes ⇒ ((process_state_r(proc) = PS_Waiting ∨ process_state_r(proc) = PS_Suspend ∨ process_state_r(proc) = PS_WaitandSuspend)⇔ process_state(proc) = TS_Waiting )) */&#10;  @inv_clocktick clock_tick ∈ ℕ&#10;  @inv_need_reschedule need_reschedule ∈ BOOL // @inv_preemption preemption_of_partitions ∈ PARTITIONS → BOOL&#10;  @inv_need_procresch need_procresch∈BOOL&#10;  @inv_preempter_of_partition preempter_of_partition ∈PARTITIONS ⤔ processes // partial injection.&#10;  @inv_locklevel_imply_preempter ∀p·(p∈PARTITIONS ∧ partition_mode(p)=PM_NORMAL ∧ locklevel_of_partition(p) &gt; 0 ⇒  p∈dom(preempter_of_partition))&#10;  @inv_locklevel_imply_preempter2 ∀p·(p∈PARTITIONS ∧ partition_mode(p)=PM_NORMAL ∧ p∈dom(preempter_of_partition) ⇒ locklevel_of_partition(p) &gt; 0 )&#10;&#10;  /* @inv_preemption_locklevel ∀p·(p∈PARTITIONS ⇒ ((locklevel_of_partition(p) &gt; 0 ⇔ preemption_of_partitions(p) = FALSE)&#10;     ∧ (locklevel_of_partition(p) = 0 ⇔ preemption_of_partitions(p) = TRUE))) */&#10;  @inv_tmout_trig_type timeout_trigger∈processes ⇸ (PROCESS_STATES × ℕ1) // a process waiting for some resource with a timeout and will be transitted to another state&#10;  @inv_tmout_trig_state ∀p·(p∈dom(timeout_trigger) ⇒ (process_state(p) = PS_Waiting ∨ process_state(p) = PS_WaitandSuspend ∨ process_state(p) = PS_Suspend)) // @inv_tmout_trig_nextstate dom(ran(timeout_trigger)) = {PS_Ready} // in the kernel, in fact, the next state when time out is always READY&#10;  @inv_errhandler_partition errorhandler_of_partition ∈ PARTITIONS ⤔ processes // partial injection. a partition has one handler at most, when error happens&#10;  @inv_errhandler_has_maxpriority ∀p·(p∈ran(errorhandler_of_partition) ⇒  (p∈dom(currentpriority_of_process) ⇒ currentpriority_of_process(p) = MAX_PRIORITY_VALUE))&#10;  @inv_errhandler_inpartition ∀part,p·(part↦p ∈ errorhandler_of_partition ⇒  processes_of_partition(p) = part) // @inv_atmostoneerrhandler_inpartition ∀p·(p∈processes ⇒ card(errorhandler_of_partition∼[{p}]) ≤ 1) // an error handler only belongs to a partition&#10;  @inv_process_call_errorhandler process_call_errorhandler ∈ processes ⤔ processes // partial injection&#10;  @inv_errhandlerandcaller_insamepart ∀p1,p2·(p1 ↦ p2 ∈ process_call_errorhandler ⇒ processes_of_partition(p1)= processes_of_partition(p2)) // error handler and its creator process is in same partition&#10;  @inv_from_errhandler_to_caller dom(process_call_errorhandler) = ran(errorhandler_of_partition) ∧ ran(process_call_errorhandler) ⊆ processes ∖ran(errorhandler_of_partition) //each error handler, this the only one caller&#10;&#10;events&#10;  event INITIALISATION extends INITIALISATION&#10;    then&#10;      @act100 process_wait_type ≔ ∅&#10;      @act10 locklevel_of_partition ≔ PARTITIONS × {1}&#10;      @act12 startcondition_of_partition ≔  ∅ // @act121 schedulable_of_partition ≔  PARTITIONS × {FALSE}&#10;      @act13 basepriority_of_process ≔ ∅&#10;      @act14 period_of_process ≔  ∅&#10;      @act15 timecapacity_of_process ≔  ∅&#10;      @act16 deadline_of_process ≔  ∅&#10;      @act17 currentpriority_of_process ≔  ∅&#10;      @act18 deadlinetime_of_process ≔  ∅&#10;      @act19 releasepoint_of_process ≔ ∅ // @act20 nextreleasepoint_of_process ≔ ∅&#10;      @act200 delaytime_of_process ≔ ∅&#10;      @act21 current_partition_flag ≔ FALSE&#10;      @act22 current_process_flag ≔ FALSE&#10;      @act23 current_partition :∈ PARTITIONS&#10;      @act24 current_process :∈ PROCESSES&#10;      @act25 clock_tick ≔ 1&#10;      @act26 need_reschedule ≔  FALSE&#10;      @act28 need_procresch ≔ FALSE&#10;      @act27 preempter_of_partition ≔ ∅&#10;      /* @act17 remain_timecapacity_of_process ≔  ∅&#10;         @act18 wakeuptime_of_process ≔  ∅&#10;         @act_asgn_preemption preemption_of_partitions ≔ PARTITIONS × {TRUE} */&#10;      @act_asgn_tmouttrig timeout_trigger ≔ ∅&#10;      @act_asgn_errhdlofpart errorhandler_of_partition ≔ ∅&#10;      @act_process_call_errorhandler process_call_errorhandler ≔ ∅&#10;  end&#10;&#10;  event ticktock // timer interrupt event, triggered by the timer in hardware. one tick in each ONE_TICK_TIME&#10;    then&#10;      @act01 clock_tick ≔ clock_tick + 1&#10;      @act02 need_reschedule ≔ TRUE&#10;  end&#10;&#10;  event partition_schedule extends partition_schedule&#10;    any found // current time is in one partition window?&#10;&#10;    where&#10;      @grd10 need_reschedule = TRUE&#10;      @grd11 found ∈ BOOL&#10;      //the next two line are commented by the reason that ARINC653 does not implement the scheduling&#10;      @grd12 ∃x,y,b,n·(((x↦y)↦b) ∈ partitionTimeWindows ∧ timeWindowsofPartition((x↦y)↦b) = part ∧&#10;            (x + n∗majorFrame) &lt; clock_tick∗ONE_TICK_TIME ∧ clock_tick∗ONE_TICK_TIME &lt; (x +y + n∗majorFrame)) ⇒found=TRUE&#10;      @grd13 ¬(∃x,y,b,n·(((x↦y)↦b) ∈ partitionTimeWindows ∧ timeWindowsofPartition((x↦y)↦b) = part ∧&#10;            (x + n∗majorFrame) &lt; clock_tick∗ONE_TICK_TIME ∧ clock_tick∗ONE_TICK_TIME &lt; (x +y + n∗majorFrame))) ⇒found=FALSE&#10;    then&#10;      @act11 current_partition_flag ≔ found&#10;      @act12 current_partition ≔ part // if flag is FALSE, the assign is arbitrary&#10;      @act13 current_process_flag ≔ FALSE&#10;      @act14 need_procresch :∣ ((partition_mode(part) = PM_NORMAL) ⇒ need_procresch' = TRUE) ∧ ((partition_mode(part) = PM_COLD_START ∨ partition_mode(part) = PM_WARM_START) ⇒ need_procresch' = FALSE )&#10;      @act15 need_reschedule :∣ ((partition_mode(part) = PM_NORMAL) ⇒ need_reschedule' = FALSE) ∧ ((partition_mode(part) = PM_COLD_START ∨ partition_mode(part) = PM_WARM_START) ⇒ need_reschedule' = TRUE )&#10;&#10;  end&#10;&#10;  event process_schedule // if there is not error handler and preempter in this partition&#10;  extends process_schedule&#10;    where&#10;      @grd10 need_procresch = TRUE&#10;      @grd11 current_partition_flag = TRUE ∧ current_partition = part&#10;      @grd12 (current_partition∉dom(errorhandler_of_partition) ∨ process_state(errorhandler_of_partition(current_partition))=PS_Dormant) ∧ locklevel_of_partition(current_partition) = 0  //current_partition∉dom(preempter_of_partition)&#10;      @grd13 ∀p·(p∈processes_of_partition∼[{part}] ⇒ currentpriority_of_process(p) ≤ currentpriority_of_process(proc))&#10;    then&#10;      @act22 current_process ≔ proc&#10;      @act24 current_process_flag ≔ TRUE&#10;      @act25 need_reschedule ≔ FALSE&#10;      @act26 need_procresch ≔ FALSE&#10;  end&#10;&#10;  event run_errorhandler_preempter // if there is the error handler, it is executed, otherwise the preempter is executed&#10;  extends process_schedule&#10;  when&#10;      @grd30 need_procresch = TRUE&#10;      @grd31 current_partition_flag = TRUE ∧ current_partition = part&#10;      @grd32 (current_partition∈dom(errorhandler_of_partition) ∧process_state(errorhandler_of_partition(current_partition))≠PS_Dormant) ∨ locklevel_of_partition(current_partition) &gt; 0 //current_partition∈dom(preempter_of_partition)&#10;      @grd33 current_partition∈dom(errorhandler_of_partition) ⇒ proc = errorhandler_of_partition(current_partition)&#10;      @grd34 current_partition∉dom(errorhandler_of_partition) ∧ locklevel_of_partition(current_partition) &gt; 0 ⇒ proc = preempter_of_partition(current_partition)&#10;    then&#10;      @act22 current_process ≔ proc&#10;      @act24 current_process_flag ≔ TRUE&#10;      //@act26 process_state(proc) ≔ PS_Running&#10;      @act25 need_reschedule ≔ FALSE&#10;      @act26 need_procresch ≔ FALSE&#10;  end&#10;&#10;&#10;  event get_partition_status&#10;    where&#10;      @grd01 current_partition_flag = TRUE&#10;  end&#10;&#10;  event set_partition_mode_to_idle // shutdown the partition&#10;  extends set_partition_mode_to_idle&#10;  when&#10;  &#9;@grd40 current_partition_flag = TRUE ∧ current_partition=part&#10;    then&#10;      @act401 process_wait_type ≔ procs ⩤ process_wait_type&#10;      @act402 locklevel_of_partition(part) ≔ 1&#10;      /* @act403 preemption_of_partitions(part) ≔ TRUE&#10;         @act404 startcondition_of_partition(part) ≔   NORMAL_START&#10;         @act404 schedulable_of_partition(part) ≔ FALSE */&#10;      @act405 basepriority_of_process ≔  procs ⩤ basepriority_of_process&#10;      @act406 period_of_process ≔   procs ⩤ period_of_process&#10;      @act407 timecapacity_of_process ≔   procs ⩤ timecapacity_of_process&#10;      @act408 deadline_of_process ≔   procs ⩤ deadline_of_process&#10;      @act409 currentpriority_of_process ≔   procs ⩤ currentpriority_of_process&#10;      @act410 deadlinetime_of_process ≔   procs ⩤ deadlinetime_of_process&#10;      @act411 releasepoint_of_process ≔   procs ⩤ releasepoint_of_process // @act412 nextreleasepoint_of_process ≔   procs ⩤ nextreleasepoint_of_process&#10;      @act413 delaytime_of_process ≔ procs ⩤ delaytime_of_process&#10;      @act414 timeout_trigger ≔  procs ⩤ timeout_trigger&#10;      @act415 errorhandler_of_partition ≔  {part} ⩤ errorhandler_of_partition&#10;      @act416 process_call_errorhandler ≔  procs ⩤ process_call_errorhandler&#10;      @act417 current_partition_flag ≔ FALSE&#10;      @act418 current_process_flag ≔ FALSE&#10;      @act419 preempter_of_partition ≔  {part} ⩤ preempter_of_partition&#10;  end&#10;&#10;  event set_partition_mode_to_normal refines set_partition_mode_to_normal&#10;    any part procs procs2 staperprocs dstaperprocs suspaperprocs stperprocs dstperprocs rlt nrlt1 nrlt2 newm dl1 dl2 dl3 dl4&#10;    where&#10;      @grd01 part ∈ PARTITIONS&#10;      @grd02 partition_mode(part) = PM_COLD_START ∨  partition_mode(part) = PM_WARM_START&#10;      @grd40 current_partition_flag = TRUE ∧ current_partition=part&#10;      @grd08 card(processes_of_partition∼[{part}]) &gt; 0&#10;      @grd09 procs =processes_of_partition∼[{part}] ∩ process_state∼[{PS_Waiting}] // transit to normal, some WAITING procs (aperiod, not suspended) will be transit to READY&#10;      @grd10 procs2 = processes_of_partition∼[{part}] ∩ process_state∼[{PS_WaitandSuspend}] // transit to normal, the WAITandSuspend procs will be transit to suspend&#10;      @grd401 staperprocs = procs ∩ period_of_process∼[{INFINITE_TIME_VALUE}] ∩ process_wait_type∼[{PROC_WAIT_PARTITIONNORMAL}]&#10;      @grd402 dstaperprocs = procs ∩ period_of_process∼[{INFINITE_TIME_VALUE}] ∩ process_wait_type∼[{PROC_WAIT_DELAY}]&#10;      @grd403 suspaperprocs = procs2&#10;      @grd404 stperprocs = (procs ∖ period_of_process∼[{INFINITE_TIME_VALUE}]) ∩ process_wait_type∼[{PROC_WAIT_PARTITIONNORMAL}]&#10;      @grd405 dstperprocs =  (procs ∖ period_of_process∼[{INFINITE_TIME_VALUE}]) ∩ process_wait_type∼[{PROC_WAIT_DELAY}]&#10;      @grd406 rlt ∈ dstaperprocs → ℕ&#10;      @grd407 ∀p·(p∈dstaperprocs ⇒ rlt(p) = clock_tick∗ONE_TICK_TIME + delaytime_of_process(p))&#10;      @grd408 nrlt1 ∈ stperprocs → ℕ&#10;      @grd409 ∀p,x,y,b·(p∈stperprocs ∧ ((x↦y)↦b)= firstperiodicprocstart_timeWindow_of_Partition(part)⇒ nrlt1(p) = ((clock_tick∗ONE_TICK_TIME)÷majorFrame+1)∗majorFrame + x)&#10;      @grd410 nrlt2 ∈ dstperprocs → ℕ&#10;      @grd411 ∀p,x,y,b·(p∈dstperprocs ∧ ((x↦y)↦b)= firstperiodicprocstart_timeWindow_of_Partition(part) ⇒ nrlt2(p) = ((clock_tick∗ONE_TICK_TIME)÷majorFrame+1)∗majorFrame + x +delaytime_of_process(p) )&#10;      @grd412 newm = PM_NORMAL&#10;      @grd413 dl1∈staperprocs ∪suspaperprocs → ℕ&#10;      @grd414 ∀p·(p∈staperprocs ∪suspaperprocs ⇒ dl1(p)=clock_tick∗ONE_TICK_TIME + timecapacity_of_process(p))&#10;      @grd415 dl2 ∈dstaperprocs → ℕ&#10;      @grd416 ∀p·(p∈dstaperprocs ⇒ dl2(p)=clock_tick∗ONE_TICK_TIME +delaytime_of_process(p)+ timecapacity_of_process(p))&#10;      @grd417 dl3∈stperprocs → ℕ&#10;      @grd418 ∀p·(p∈stperprocs ⇒ dl3(p)=clock_tick∗ONE_TICK_TIME +timecapacity_of_process(p))&#10;      @grd419 dl4∈dstperprocs → ℕ&#10;      @grd420 ∀p·(p∈dstperprocs ⇒ dl4(p)=clock_tick∗ONE_TICK_TIME +delaytime_of_process(p) + timecapacity_of_process(p))&#10;    with&#10;      @procsstate procsstate = (staperprocs ×{PS_Ready}) ∪ ((dstaperprocs ∪ stperprocs ∪ dstperprocs)×{PS_Waiting})&#10;    then&#10;      @act400 partition_mode(part) ≔ newm&#10;      @act401 process_state ≔  (process_state (staperprocs ×{PS_Ready}))  (suspaperprocs × {PS_Suspend})&#10;      @act402 releasepoint_of_process ≔  releasepoint_of_process  rlt nrlt1  nrlt2 // @act403 nextreleasepoint_of_process ≔  nextreleasepoint_of_process nrlt1  nrlt2&#10;      @act403 deadlinetime_of_process ≔  deadlinetime_of_process  dl1  dl2  dl3  dl4&#10;      @act404 locklevel_of_partition(part) ≔ 0 // @act405 schedulable_of_partition(part) ≔ TRUE&#10;  end&#10;&#10;  event set_partition_mode_to_coldstart extends set_partition_mode_to_coldstart&#10;    when&#10;  &#9;  @grd40 current_partition_flag = TRUE ∧ current_partition=part&#10;    then&#10;      @act401 process_wait_type ≔ procs ⩤ process_wait_type&#10;      @act402 locklevel_of_partition(part) ≔ 1&#10;      /* @act403 preemption_of_partitions(part) ≔ TRUE&#10;         @act404 startcondition_of_partition(part) ≔   NORMAL_START&#10;         @act404 schedulable_of_partition(part) ≔ FALSE */&#10;      @act405 basepriority_of_process ≔  procs ⩤ basepriority_of_process&#10;      @act406 period_of_process ≔   procs ⩤ period_of_process&#10;      @act407 timecapacity_of_process ≔   procs ⩤ timecapacity_of_process&#10;      @act408 deadline_of_process ≔   procs ⩤ deadline_of_process&#10;      @act409 currentpriority_of_process ≔   procs ⩤ currentpriority_of_process&#10;      @act410 deadlinetime_of_process ≔   procs ⩤ deadlinetime_of_process&#10;      @act411 releasepoint_of_process ≔   procs ⩤ releasepoint_of_process // @act412 nextreleasepoint_of_process ≔   procs ⩤ nextreleasepoint_of_process&#10;      @act413 delaytime_of_process ≔ procs ⩤ delaytime_of_process&#10;      @act414 timeout_trigger ≔  procs ⩤ timeout_trigger&#10;      @act415 errorhandler_of_partition ≔  {part} ⩤ errorhandler_of_partition&#10;      @act416 process_call_errorhandler ≔  procs ⩤ process_call_errorhandler // @act417 current_partition_flag ≔ FALSE&#10;      @act418 current_process_flag ≔ FALSE&#10;      @act419 preempter_of_partition ≔  {part} ⩤ preempter_of_partition&#10;  end&#10;&#10;  event set_partition_mode_to_warmstart extends set_partition_mode_to_warmstart&#10;    when&#10;  &#9;  @grd40 current_partition_flag = TRUE ∧ current_partition=part&#10;    then&#10;      @act401 process_wait_type ≔ procs ⩤ process_wait_type&#10;      @act402 locklevel_of_partition(part) ≔ 1&#10;      /* @act403 preemption_of_partitions(part) ≔ TRUE&#10;         @act404 startcondition_of_partition(part) ≔   NORMAL_START&#10;         @act404 schedulable_of_partition(part) ≔ FALSE */&#10;      @act405 basepriority_of_process ≔  procs ⩤ basepriority_of_process&#10;      @act406 period_of_process ≔   procs ⩤ period_of_process&#10;      @act407 timecapacity_of_process ≔   procs ⩤ timecapacity_of_process&#10;      @act408 deadline_of_process ≔   procs ⩤ deadline_of_process&#10;      @act409 currentpriority_of_process ≔   procs ⩤ currentpriority_of_process&#10;      @act410 deadlinetime_of_process ≔   procs ⩤ deadlinetime_of_process&#10;      @act411 releasepoint_of_process ≔   procs ⩤ releasepoint_of_process // @act412 nextreleasepoint_of_process ≔   procs ⩤ nextreleasepoint_of_process&#10;      @act413 delaytime_of_process ≔ procs ⩤ delaytime_of_process&#10;      @act414 timeout_trigger ≔  procs ⩤ timeout_trigger&#10;      @act415 errorhandler_of_partition ≔  {part} ⩤ errorhandler_of_partition&#10;      @act416 process_call_errorhandler ≔  procs ⩤ process_call_errorhandler // @act417 current_partition_flag ≔ FALSE&#10;      @act418 current_process_flag ≔ FALSE&#10;      @act419 preempter_of_partition ≔  {part} ⩤ preempter_of_partition&#10;  end&#10;&#10;  event get_process_id&#10;    any proc&#10;    where&#10;      @grd01 current_partition_flag = TRUE&#10;      @grd02 proc ∈ processes&#10;      @grd03 processes_of_partition(proc) = current_partition&#10;  end&#10;&#10;  event get_process_status&#10;    any proc&#10;    where&#10;      @grd01 current_partition_flag = TRUE&#10;      @grd02 proc ∈ processes&#10;      @grd03 processes_of_partition(proc) = current_partition&#10;  end&#10;&#10;  event create_process extends create_process&#10;    any basepriority period timecapacity dl&#10;    where&#10;      @grd201 current_partition_flag = TRUE&#10;      @grd200 part = current_partition&#10;      @grd20 basepriority ∈ MIN_PRIORITY_VALUE ‥ MAX_PRIORITY_VALUE&#10;      @grd21 period ∈ ℤ&#10;      @grd22 timecapacity ∈ ℤ&#10;      @grd23 period≠ INFINITE_TIME_VALUE ⇒ (∃n·(n∈ℕ ∧period =n∗Period_of_Partition(part)))&#10;      @grd24 period≠ INFINITE_TIME_VALUE ⇒ (timecapacity ≤ period)&#10;      @grd25 dl ∈DEADLINE_TYPE&#10;      @ptype1 (ptype=APERIOD_PROC⇔ period=INFINITE_TIME_VALUE)&#10;      @ptype2 (ptype=PERIOD_PROC⇔ period≠INFINITE_TIME_VALUE)&#10;    then&#10;      @act21 basepriority_of_process(proc) ≔ basepriority&#10;      @act22 period_of_process(proc) ≔  period&#10;      @act23 timecapacity_of_process(proc) ≔  timecapacity&#10;      @act34 deadline_of_process(proc) ≔  dl&#10;      @act35 currentpriority_of_process(proc) ≔  basepriority&#10;&#10;      //@act36 process_ids ≔ process_ids ∪ {proc}&#10;  end&#10;&#10;  event set_priority&#10;    any p pri&#10;    where&#10;      @grd10 current_partition_flag = TRUE&#10;      @grd11 p ∈processes&#10;      @grd12 p ∈ processes_of_partition∼[{current_partition}]&#10;      @grd14 pri ∈ MIN_PRIORITY_VALUE ‥ MAX_PRIORITY_VALUE&#10;      @grd15 process_state(p) ≠ PS_Dormant&#10;      //@grd16 p∉ran(errorhandler_of_partition)&#10;    then&#10;      @act10 currentpriority_of_process(p) ≔ pri&#10;      //@act11 need_reschedule :∣ (locklevel_of_partition(current_partition) =0 ∧(process_state(p)=PS_Ready ∨ process_state(p)=PS_Running)⇒ need_reschedule' = TRUE) ∧ (locklevel_of_partition(current_partition) ≠0 ⇒ need_reschedule' = need_reschedule)&#10;      @act11 need_reschedule :∣ (locklevel_of_partition(current_partition) =0 ⇒ need_reschedule' = TRUE) ∧ (locklevel_of_partition(current_partition) ≠0 ⇒ need_reschedule' = need_reschedule)&#10;  end&#10;&#10;  event suspend_self&#10;  //extends suspend_self&#10; //   any timeout timeouttrig waittype&#10; refines suspend_self&#10; any part proc newstate timeout timeouttrig waittype&#10;    where&#10;      @grd01 part ∈ PARTITIONS&#10;&#9;@grd02 proc ∈ processes&#10;&#9;@grd03 newstate ∈ PROCESS_STATES&#10;&#9;@grd06 processes_of_partition(proc) = part&#10;  &#9;@grd31 partition_mode(part) = PM_NORMAL&#10;  &#9;@grd32 process_state(proc) = PS_Running&#10;  &#9;@grd33 newstate = PS_Suspend&#10;  &#9;@grd34 periodtype_of_process(proc) = APERIOD_PROC&#10;&#10;      @grd401 timeout∈ℤ ∧ timeout≠0&#10;      @grd402 current_process_flag = TRUE ∧ current_partition_flag = TRUE&#10;      @grd200 part = current_partition&#10;      @grd403 proc = current_process&#10;      @grd404 part∈dom(errorhandler_of_partition) ⇒ proc ≠ errorhandler_of_partition(part)&#10;      @grd405 locklevel_of_partition(part) = 0&#10;      @grd406 period_of_process(proc) ≠ INFINITE_TIME_VALUE&#10;      @grd407 timeouttrig ∈ processes ⇸ (PROCESS_STATES × ℕ1)&#10;      @grd408 timeout ≠ INFINITE_TIME_VALUE ∧ timeout≠0⇒ timeouttrig = {proc ↦ (PS_Ready ↦ (timeout +clock_tick ∗ ONE_TICK_TIME))}&#10;      @grd409 timeout = INFINITE_TIME_VALUE ⇒  timeouttrig = ∅&#10;      @grd410 waittype∈processes⇸PROCESS_WAIT_TYPES&#10;      @grd411 timeout&gt;0 ⇒ waittype={proc ↦ PROC_WAIT_TIMEOUT}&#10;      @grd412 (timeout =  INFINITE_TIME_VALUE ∨ timeout = 0) ⇒ waittype = ∅&#10;    then&#10;      @act11 process_state(proc) ≔ newstate&#10;      @act40 current_process_flag :∣(timeout=0⇒current_process_flag' = TRUE) ∧ (timeout&gt;0⇒current_process_flag' = FALSE)&#10;      @act41 timeout_trigger ≔ timeout_trigger  timeouttrig&#10;      @act42 need_reschedule :∣(timeout=0⇒need_reschedule' = FALSE) ∧ (timeout&gt;0⇒need_reschedule' = TRUE)&#10;      @act43 process_wait_type ≔  process_wait_type  waittype&#10;  end&#10;&#10;  event suspend&#10;  //extends suspend&#10;  refines suspend&#10;  any part proc newstate&#10;    where&#10;      @grd01 part ∈ PARTITIONS&#10;&#9;@grd02 proc ∈ processes&#10;&#9;@grd03 newstate ∈ PROCESS_STATES&#10;&#9;@grd06 processes_of_partition(proc) = part&#10;&#9;@grd30 partition_mode(part) = PM_NORMAL ∨ partition_mode(part) = PM_COLD_START ∨ partition_mode(part) = PM_WARM_START&#10;&#9;@grd31 partition_mode(part) = PM_NORMAL ⇒  (process_state(proc) = PS_Ready ∧ newstate = PS_Suspend)∨  (process_state(proc) = PS_Waiting ∧ newstate = PS_WaitandSuspend)&#10;  &#9;@grd32 (partition_mode(part) = PM_COLD_START ∨  partition_mode(part) = PM_WARM_START)⇒  (process_state(proc) = PS_Waiting ∧ newstate = PS_WaitandSuspend)&#10;&#10;      @grd40 current_process_flag = TRUE ∧ current_partition_flag = TRUE&#10;      @grd200 part = current_partition&#10;      @grd41 current_process_flag = TRUE ⇒ proc ≠ current_process&#10;      @grd42 locklevel_of_partition(part) = 0 ∨ proc ∉ ran(process_call_errorhandler) // preemption is enabled or the PROCESS_ID is not the process which the error handler has pre-empted&#10;      @grd43 period_of_process(proc) = INFINITE_TIME_VALUE // periodic process could not be suspend&#10;      @grd45 process_state(proc) ≠ PS_Dormant&#10;      @grd46 process_state(proc) ≠PS_Suspend ∧  process_state(proc) ≠PS_WaitandSuspend&#10;&#10;  then&#10;  &#9;@act11 process_state(proc) ≔ newstate&#10;  end&#10;&#10;  event resume&#10;  //extends resume&#10;  refines resume&#10;    any part proc newstate reschedule&#10;    where&#10;      @grd01 part ∈ PARTITIONS&#10;&#9;@grd02 proc ∈ processes&#10;&#9;@grd03 newstate ∈ PROCESS_STATES&#10;&#9;@grd06 processes_of_partition(proc) = part&#10;&#9;@grd31 partition_mode(part) = PM_NORMAL ∨ partition_mode(part) = PM_COLD_START ∨ partition_mode(part) = PM_WARM_START&#10;&#10;      @grd40 current_partition_flag = TRUE&#10;      @grd200 part = current_partition&#10;      @grd41 current_process_flag = TRUE ⇒ proc ≠ current_process&#10;      @grd42 process_state(proc) ≠ PS_Dormant&#10;      @grd43 period_of_process(proc) = INFINITE_TIME_VALUE&#10;      @grd44 process_state(proc) =PS_Suspend ∨  process_state(proc) = PS_WaitandSuspend&#10;      @grd45 reschedule ∈ BOOL&#10;      @grd46 (process_state(proc) = PS_Suspend ⇒ reschedule = TRUE) ∧ (process_state(proc) = PS_WaitandSuspend ⇒ reschedule = FALSE)&#10;&#10;      //@grd47 process_state(proc) =PS_Suspend ∨ (process_state(proc) =PS_WaitandSuspend ∧ process_wait_type(proc)≠PROC_WAIT_TIMEOUT ∧ process_wait_type(proc)≠PROC_WAIT_OBJ) ⇒ newstate = PS_Ready&#10;      //@grd48 process_state(proc) =PS_WaitandSuspend ∧ process_wait_type(proc)=PROC_WAIT_TIMEOUT ∧ process_wait_type(proc)=PROC_WAIT_OBJ ⇒ newstate = PS_Waiting&#10;      //these two lines are from RESUME operation of ARINC653, the next two lines are correct&#10;      @grd47 process_state(proc) =PS_Suspend ⇒ newstate = PS_Ready&#10;      @grd48 process_state(proc) =PS_WaitandSuspend ⇒ newstate = PS_Waiting&#10;&#10;    then&#10;      @act11 process_state(proc) ≔ newstate&#10;      @act41 timeout_trigger :∣  (newstate = PS_Ready ⇒ timeout_trigger'=  {proc}⩤ timeout_trigger) ∧ (newstate ≠ PS_Ready ⇒ timeout_trigger'=timeout_trigger)&#10;      @act42 need_reschedule :∣ (locklevel_of_partition(current_partition) =0 ∧  reschedule = TRUE ⇒ need_reschedule' = TRUE)&#10;             ∧ (locklevel_of_partition(current_partition) &gt; 0 ∨  reschedule = FALSE ⇒ need_reschedule' = need_reschedule)&#10;  end&#10;&#10;  event stop_self refines stop_self&#10;    any part proc newstate newlocklevel newproc resch&#10;    where&#10;      @grd01 part ∈ PARTITIONS&#10;&#9;@grd02 proc ∈ processes&#10;&#9;@grd03 newstate ∈ PROCESS_STATES&#10;&#9;@grd06 processes_of_partition(proc) = part&#10;&#9;@grd30 partition_mode(part) = PM_NORMAL&#10;&#10;      @grd40 current_process_flag = TRUE ∧ current_partition_flag = TRUE&#10;      @grd42 proc = current_process&#10;      @grd43 (part∉dom(errorhandler_of_partition) ∨ proc ≠ errorhandler_of_partition(part)) ⇒ newlocklevel = {part ↦ 0}&#10;&#9;  @grd44 (part∈dom(errorhandler_of_partition) ∧ proc = errorhandler_of_partition(part)) ⇒ newlocklevel = ∅&#10;      @grd45 part∈dom(errorhandler_of_partition) ∧ proc = errorhandler_of_partition(part) ∧ locklevel_of_partition(current_partition) &gt; 0&#10;             ∧ process_state(process_call_errorhandler(proc))≠PS_Dormant ⇒   (newproc = process_call_errorhandler(proc) ∧ resch = FALSE) // If (current process is the error handler process and preemption is disabled and previous process is not stopped) then return to previous process&#10;      @grd46 ¬(part∈dom(errorhandler_of_partition) ∧ proc = errorhandler_of_partition(part) ∧ locklevel_of_partition(current_partition) &gt; 0&#10;             ∧ process_state(process_call_errorhandler(proc))≠PS_Dormant) ⇒   (newproc = proc ∧ resch = TRUE) // If (current process is the error handler process and preemption is disabled and previous process is not stopped) then return to previous process&#10;       @grd47 newstate = PS_Dormant&#10;    then&#10;      @act11 process_state(proc) ≔ newstate&#10;      @act41 current_process_flag :∣ (resch = FALSE ⇒ current_process_flag'=TRUE) ∧ (resch = TRUE ⇒ current_process_flag'=FALSE)&#10;      @act42 locklevel_of_partition ≔  locklevel_of_partition newlocklevel&#10;      @act43 current_process ≔ newproc&#10;      @act44 need_reschedule :∣ (resch = TRUE ⇒  need_reschedule' = TRUE) ∧ (resch = FALSE ⇒   need_reschedule' = need_reschedule)&#10;  end&#10;&#10;  event stop refines stop&#10;    any part proc newstate newlocklevel&#10;    where&#10;      @grd01 part ∈ PARTITIONS&#10;&#9;@grd02 proc ∈ processes&#10;&#9;@grd03 newstate ∈ PROCESS_STATES&#10;&#9;@grd06 processes_of_partition(proc) = part&#10;&#9;@grd31 partition_mode(part) = PM_NORMAL ∨ partition_mode(part) = PM_COLD_START ∨ partition_mode(part) = PM_WARM_START&#10;&#10;      @grd41 current_partition_flag = TRUE&#10;      @grd42 current_process_flag = TRUE ⇒ proc ≠ current_process&#10;      @grd200 part = current_partition&#10;      @grd43 process_state(proc) ≠ PS_Dormant&#10;      @grd45 (current_process_flag = TRUE ∧ part∈dom(errorhandler_of_partition) ∧ current_process = errorhandler_of_partition(part)&#10;             ∧ proc = process_call_errorhandler(current_process))⇒ newlocklevel = {part ↦ 0}&#10;&#9;  @grd46 ¬(current_process_flag = TRUE ∧ part∈dom(errorhandler_of_partition) ∧ current_process = errorhandler_of_partition(part)&#10;             ∧ proc = process_call_errorhandler(current_process))⇒ newlocklevel = ∅&#10;      @grd47 newstate = PS_Dormant&#10;    then&#10;      @act11 process_state(proc) ≔ newstate&#10;      @act41 locklevel_of_partition ≔  locklevel_of_partition newlocklevel&#10;      @act42 timeout_trigger ≔  {proc}⩤ timeout_trigger&#10;      //need to add statement of remove proc from deadlinetime, releasepoint, delaytime,errorhandler, process_call_errorhandler&#10;  end&#10;&#10;  event start_aperiodprocess_instart // start an aperiodic process in COLD_START or WARM_START mode&#10;  //extends start&#10;  refines start&#10;  any part proc newstate&#10;    where&#10;      @grd01 part ∈ PARTITIONS&#10;&#9;@grd02 proc ∈ processes&#10;&#9;@grd03 newstate ∈ PROCESS_STATES&#10;&#9;@grd06 processes_of_partition(proc) = part&#10;&#10;      @grd41 current_partition_flag = TRUE&#10;      @grd40 part = current_partition&#10;      @grd43 partition_mode(part) = PM_COLD_START ∨  partition_mode(part) = PM_WARM_START&#10;      @grd44 process_state(proc) = PS_Dormant&#10;      @grd45 newstate = PS_Waiting&#10;      @grd46 period_of_process(proc) = INFINITE_TIME_VALUE&#10;    then&#10;      @act11 process_state(proc) ≔ newstate&#10;      @act41 currentpriority_of_process(proc) ≔ basepriority_of_process(proc)&#10;      @act42 process_wait_type(proc) ≔ PROC_WAIT_PARTITIONNORMAL&#10;  end&#10;&#10;  event start_aperiodprocess_innormal // start an aperiodic process in NORMAL mode&#10; //extends start&#10;  refines start&#10;  any part proc newstate&#10;    where&#10;      @grd01 part ∈ PARTITIONS&#10;&#9;@grd02 proc ∈ processes&#10;&#9;@grd03 newstate ∈ PROCESS_STATES&#10;&#9;@grd06 processes_of_partition(proc) = part&#10;&#10;      @grd41 current_process_flag = TRUE ∧ current_partition_flag = TRUE&#10;      @grd40 part = current_partition&#10;      @grd43 partition_mode(part) = PM_NORMAL&#10;      @grd44 process_state(proc) = PS_Dormant&#10;      @grd45 newstate = PS_Ready&#10;      @grd47 period_of_process(proc) = INFINITE_TIME_VALUE&#10;    then&#10;      @act11 process_state(proc) ≔ newstate&#10;      @act03 currentpriority_of_process(proc) ≔ basepriority_of_process(proc)&#10;      @act04 deadlinetime_of_process(proc) ≔  clock_tick∗ ONE_TICK_TIME + timecapacity_of_process(proc)&#10;      @act05 need_reschedule :∣ (locklevel_of_partition(part) =0 ⇒ need_reschedule'=TRUE)&#10;             ∧ (locklevel_of_partition(part) &gt; 0 ⇒ need_reschedule'=need_reschedule)&#10;  end&#10;&#10;  event start_periodprocess_instart // start a periodic process in COLD_START or WARM_START mode&#10;  //extends start&#10;  refines start&#10;  any part proc newstate&#10;    where&#10;      @grd01 part ∈ PARTITIONS&#10;&#9;@grd02 proc ∈ processes&#10;&#9;@grd03 newstate ∈ PROCESS_STATES&#10;&#9;@grd06 processes_of_partition(proc) = part&#10;&#10;      @grd41 current_partition_flag = TRUE&#10;      @grd40 part = current_partition&#10;      @grd42 partition_mode(part) = PM_COLD_START ∨  partition_mode(part) = PM_WARM_START&#10;      @grd43 process_state(proc) = PS_Dormant&#10;      @grd44 newstate = PS_Waiting&#10;      @grd45 period_of_process(proc) ≠ INFINITE_TIME_VALUE&#10;    then&#10;      @act11 process_state(proc) ≔ newstate&#10;      @act03 currentpriority_of_process(proc) ≔ basepriority_of_process(proc)&#10;      @act42 process_wait_type(proc) ≔ PROC_WAIT_PARTITIONNORMAL&#10;  end&#10;&#10;  event start_periodprocess_innormal // start a periodic process in NORMAL mode&#10;  //extends start&#10;  refines start&#10;  any part proc newstate fstrl&#10;    where&#10;      @grd01 part ∈ PARTITIONS&#10;&#9;@grd02 proc ∈ processes&#10;&#9;@grd03 newstate ∈ PROCESS_STATES&#10;&#9;@grd06 processes_of_partition(proc) = part&#10;&#10;      @grd41 current_process_flag = TRUE ∧ current_partition_flag = TRUE&#10;      @grd40 part = current_partition&#10;      @grd43 partition_mode(part) = PM_NORMAL&#10;      @grd44 process_state(proc) = PS_Dormant&#10;      @grd45 newstate = PS_Waiting&#10;      @grd46 fstrl ∈ ℕ1&#10;      @grd47 period_of_process(proc) ≠ INFINITE_TIME_VALUE&#10;      @grd48 ∃x,y,b·( ((x↦y)↦b)= firstperiodicprocstart_timeWindow_of_Partition(part)⇒ fstrl= ((clock_tick∗ONE_TICK_TIME)÷majorFrame+1)∗majorFrame + x)&#10;    then&#10;      @act11 process_state(proc) ≔ newstate&#10;      @act03 currentpriority_of_process(proc) ≔ basepriority_of_process(proc)&#10;      @act05 releasepoint_of_process(proc) ≔ fstrl&#10;      @act04 deadlinetime_of_process(proc) ≔  fstrl + timecapacity_of_process(proc)&#10;      @act42 process_wait_type(proc) ≔ PROC_WAIT_PERIOD&#10;  end&#10;&#10;  event delaystart_aperiodprocess_instart&#10;  //extends delayed_start&#10;  refines delayed_start&#10;    any part proc newstate delaytime&#10;    where&#10;      @grd01 part ∈ PARTITIONS&#10;&#9;@grd02 proc ∈ processes&#10;&#9;@grd03 newstate ∈ PROCESS_STATES&#10;&#9;@grd06 processes_of_partition(proc) = part&#10;&#10;      @grd400 delaytime ∈ ℕ ∧ delaytime≠INFINITE_TIME_VALUE&#10;      @grd41 current_partition_flag = TRUE&#10;      @grd40 part = current_partition&#10;      @grd43 partition_mode(part) = PM_COLD_START ∨  partition_mode(part) = PM_WARM_START&#10;      @grd44 process_state(proc) = PS_Dormant&#10;      @grd45 newstate = PS_Waiting&#10;      @grd46 period_of_process(proc) = INFINITE_TIME_VALUE&#10;    then&#10;      @act11 process_state(proc) ≔ newstate&#10;      @act41 currentpriority_of_process(proc) ≔ basepriority_of_process(proc)&#10;      @act42 process_wait_type(proc)≔PROC_WAIT_DELAY&#10;      @act43 delaytime_of_process(proc) ≔   delaytime&#10;  end&#10;&#10;  event delaystart_aperiodprocess_innormal // if delaytime=0, then immediately transit to READY, this is modelled in start_aperiod_process_whennormal&#10;  //extends delayed_start&#10;  //  any delaytime&#10;  refines delayed_start&#10;  any part proc newstate delaytime&#10;    where&#10;      @grd01 part ∈ PARTITIONS&#10;&#9;@grd02 proc ∈ processes&#10;&#9;@grd03 newstate ∈ PROCESS_STATES&#10;&#9;@grd06 processes_of_partition(proc) = part&#10;&#10;      @grd40 delaytime &gt; 0 ∧ delaytime≠INFINITE_TIME_VALUE&#10;      @grd41 current_process_flag = TRUE ∧ current_partition_flag = TRUE&#10;      @grd42 part = current_partition&#10;      @grd43 partition_mode(part) = PM_NORMAL&#10;      @grd44 process_state(proc) = PS_Dormant&#10;      @grd45 newstate = PS_Waiting&#10;      @grd47 period_of_process(proc) = INFINITE_TIME_VALUE&#10;    then&#10;      @act11 process_state(proc) ≔ newstate&#10;      @act41 currentpriority_of_process(proc) ≔ basepriority_of_process(proc)&#10;      @act42 deadlinetime_of_process(proc) ≔  clock_tick∗ ONE_TICK_TIME + timecapacity_of_process(proc) + delaytime&#10;      @act43 timeout_trigger ≔  timeout_trigger  {proc ↦ (PS_Ready↦ (delaytime +clock_tick ∗ ONE_TICK_TIME))}&#10;      @act44 need_reschedule :∣ (locklevel_of_partition(part) =0 ⇒ need_reschedule'=TRUE)&#10;             ∧ (locklevel_of_partition(part) &gt; 0 ⇒ need_reschedule'=need_reschedule)&#10;      @act45 process_wait_type(proc)≔PROC_WAIT_DELAY&#10;      @act46 delaytime_of_process(proc) ≔   delaytime&#10;  end&#10;&#10;  event delaystart_periodprocess_instart&#10;  //extends delayed_start&#10;  refines delayed_start&#10;    any part proc newstate delaytime&#10;    where&#10;      @grd01 part ∈ PARTITIONS&#10;&#9;@grd02 proc ∈ processes&#10;&#9;@grd03 newstate ∈ PROCESS_STATES&#10;&#9;@grd06 processes_of_partition(proc) = part&#10;&#10;      @grd400 delaytime ∈ ℕ ∧ delaytime≠INFINITE_TIME_VALUE ∧ delaytime &lt; period_of_process(proc)&#10;      @grd41 current_partition_flag = TRUE&#10;      @grd40 part = current_partition&#10;      @grd42 partition_mode(part) = PM_COLD_START ∨  partition_mode(part) = PM_WARM_START&#10;      @grd43 process_state(proc) = PS_Dormant&#10;      @grd44 newstate = PS_Waiting&#10;      @grd45 period_of_process(proc) ≠ INFINITE_TIME_VALUE&#10;    then&#10;      @act11 process_state(proc) ≔ newstate&#10;      @act41 currentpriority_of_process(proc) ≔ basepriority_of_process(proc)&#10;      @act42 process_wait_type(proc)≔PROC_WAIT_DELAY&#10;      @act43 delaytime_of_process(proc) ≔   delaytime&#10;  end&#10;&#10;  event delaystart_periodprocess_innormal&#10;  //extends delayed_start&#10;  refines delayed_start&#10;    any part proc newstate delaytime fstrl&#10;    where&#10;      @grd01 part ∈ PARTITIONS&#10;&#9;@grd02 proc ∈ processes&#10;&#9;@grd03 newstate ∈ PROCESS_STATES&#10;&#9;@grd06 processes_of_partition(proc) = part&#10;&#10;      @grd41 delaytime ∈ ℕ ∧ delaytime≠INFINITE_TIME_VALUE ∧ delaytime &lt; period_of_process(proc)&#10;      @grd42 current_process_flag = TRUE ∧ current_partition_flag = TRUE&#10;      @grd40 part = current_partition&#10;      @grd43 partition_mode(part) = PM_NORMAL&#10;      @grd44 process_state(proc) = PS_Dormant&#10;      @grd45 newstate = PS_Waiting&#10;      @grd46 fstrl ∈ ℕ1&#10;      @grd47 period_of_process(proc) ≠ INFINITE_TIME_VALUE&#10;      @grd48 ∃x,y,b·( ((x↦y)↦b)= firstperiodicprocstart_timeWindow_of_Partition(part)⇒ fstrl= ((clock_tick∗ONE_TICK_TIME)÷majorFrame+1)∗majorFrame + x)&#10;    then&#10;      @act11 process_state(proc) ≔ newstate&#10;      @act41 currentpriority_of_process(proc) ≔ basepriority_of_process(proc)&#10;      @act42 releasepoint_of_process(proc) ≔ fstrl + delaytime&#10;      @act43 deadlinetime_of_process(proc) ≔  fstrl +delaytime + timecapacity_of_process(proc)&#10;      @act45 process_wait_type(proc)≔PROC_WAIT_DELAY&#10;      @act46 delaytime_of_process(proc) ≔   delaytime&#10;  end&#10;&#10;  event lock_preemption&#10;    any part&#10;    where&#10;      @grd0 current_process_flag = TRUE ∧ current_partition_flag = TRUE&#10;      @grd01 part ∈ PARTITIONS ∧ part = current_partition&#10;      @grd02 part∈dom(errorhandler_of_partition) ⇒ current_process ≠ errorhandler_of_partition(part)&#10;      @grd03 partition_mode(part) = PM_NORMAL&#10;      @grd04 locklevel_of_partition(part) &lt; MAX_LOCK_LEVEL&#10;    then&#10;      @act01 locklevel_of_partition(part) ≔ locklevel_of_partition(part) + 1&#10;      @act02 preempter_of_partition(part) ≔ current_process&#10;  end&#10;&#10;  event unlock_preemption&#10;    any part resched preempter&#10;    where&#10;      @grd0 current_process_flag = TRUE ∧ current_partition_flag = TRUE&#10;      @grd01 part ∈ PARTITIONS ∧ part = current_partition&#10;      @grd02 part∈dom(errorhandler_of_partition) ⇒ current_process ≠ errorhandler_of_partition(part)&#10;      @grd03 partition_mode(part) = PM_NORMAL&#10;      @grd04 locklevel_of_partition(part) &gt; 0&#10;      @grd05 locklevel_of_partition(part) = 1 ⇒ resched = TRUE&#10;      @grd06 locklevel_of_partition(part) &gt; 1 ⇒ resched = FALSE&#10;      @grd07 locklevel_of_partition(part) = 1 ⇒ preempter = {(part ↦ current_process)}&#10;      @grd08 locklevel_of_partition(part) &gt; 1 ⇒ preempter = ∅&#10;    then&#10;      @act01 locklevel_of_partition(part) ≔ locklevel_of_partition(part) − 1&#10;      @act02 need_reschedule :∣ (resched = TRUE ⇒ need_reschedule'=TRUE)&#10;             ∧ (resched = FALSE ⇒ need_reschedule'=need_reschedule)&#10;      @act03 preempter_of_partition ≔  preempter_of_partition ∖ preempter&#10;  end&#10;&#10;  event get_my_id&#10;    where&#10;      @grd0 current_process_flag = TRUE ∧ current_partition_flag = TRUE&#10;      @grd01 current_partition∈dom(errorhandler_of_partition) ⇒ current_process ≠ errorhandler_of_partition(current_partition)&#10;  end&#10;&#10;  event timed_wait extends timed_wait&#10;    any delaytime tmout_trig wt&#10;    where&#10;      @grd40 delaytime ≠ INFINITE_TIME_VALUE&#10;      @grd41 current_process_flag = TRUE ∧ current_partition_flag = TRUE&#10;      @grd42 part = current_partition&#10;      @grd43 proc = current_process&#10;      @grd44 current_partition∈dom(errorhandler_of_partition) ⇒ current_process ≠ errorhandler_of_partition(current_partition)&#10;      @grd45 locklevel_of_partition(current_partition) = 0&#10;      @grd36 tmout_trig ∈ processes ⇸ (PROCESS_STATES × ℕ1)&#10;      @grd37 (delaytime = 0 ⇒ (newstate = PS_Ready ∧ tmout_trig = ∅ ∧ wt=∅))&#10;             ∧ (delaytime &gt;0 ⇒ (newstate = PS_Waiting ∧ wt={proc↦PROC_WAIT_TIMEOUT} ∧ tmout_trig = {current_process↦(PS_Ready↦ (delaytime +clock_tick ∗ ONE_TICK_TIME))}))&#10;    then&#10;      @act05 timeout_trigger ≔ timeout_trigger   tmout_trig&#10;      @act04 process_wait_type ≔ process_wait_type  wt&#10;      @act06 need_reschedule ≔ TRUE&#10;      @act07 current_process_flag ≔ FALSE&#10;  end&#10;&#10;  event period_wait extends period_wait&#10;    where&#10;      @grd40 current_process_flag = TRUE ∧ current_partition_flag = TRUE&#10;      @grd41 part = current_partition&#10;      @grd42 proc = current_process&#10;      @grd43 current_partition∈dom(errorhandler_of_partition) ⇒ current_process ≠ errorhandler_of_partition(current_partition)&#10;      @grd44 locklevel_of_partition(current_partition) = 0&#10;      @grd45 period_of_process(proc) ≠ INFINITE_TIME_VALUE // requesting process is not aperiodic&#10;    then&#10;      @act41 releasepoint_of_process(proc) ≔  releasepoint_of_process(proc) + period_of_process(proc)&#10;      /* Next release point := process period plus previous release point;&#10;         @act42 nextreleasepoint_of_process(proc) ≔  nextreleasepoint_of_process(proc) + period_of_process(proc) */&#10;      @act43 deadlinetime_of_process(proc) ≔   releasepoint_of_process(proc) + timecapacity_of_process(proc)&#10;      @act44 need_reschedule ≔ TRUE&#10;      @act45 current_process_flag ≔ FALSE&#10;  end&#10;&#10;  event get_time&#10;  when&#10;  &#9;@grd01 current_process_flag = TRUE ∧ current_partition_flag = TRUE&#10;    @grd02 partition_mode(current_partition) = PM_NORMAL&#10;  end&#10;&#10;  event replenish&#10;    any budget_time ddtm&#10;    where&#10;      @grd01 budget_time ∈ ℤ&#10;      @grd02 current_process_flag = TRUE ∧ current_partition_flag = TRUE&#10;      @grd03 partition_mode(current_partition) = PM_NORMAL&#10;      @grd04 current_partition∈dom(errorhandler_of_partition) ⇒ current_process ≠ errorhandler_of_partition(current_partition)&#10;      @grd05 period_of_process(current_process) ≠ INFINITE_TIME_VALUE&#10;             ∧ clock_tick ∗ ONE_TICK_TIME + budget_time ≤ releasepoint_of_process(current_process)+timecapacity_of_process(current_process)&#10;      /* requesting process is not aperiodic&#10;         requesting process is aperiodic or new deadline will not exceed next release point */&#10;      @grd06 ddtm∈ℤ&#10;      @grd07 budget_time &gt; 0 ⇒ ddtm = clock_tick ∗ ONE_TICK_TIME + budget_time&#10;      @grd08 (budget_time = INFINITE_TIME_VALUE ∨ timecapacity_of_process(current_process)=INFINITE_TIME_VALUE) ⇒ ddtm = INFINITE_TIME_VALUE&#10;    then&#10;      @act01 deadlinetime_of_process(current_process) ≔ ddtm&#10;  end&#10;&#10;  event aperiodicprocess_finished extends process_finished&#10;    where&#10;      @grd40 current_partition_flag = TRUE ∧ current_process_flag = TRUE&#10;      @grd41 part = current_partition&#10;      @grd42 proc = current_process&#10;      @grd44 newstate = PS_Dormant&#10;      @grd45 period_of_process(proc) = INFINITE_TIME_VALUE&#10;    then&#10;      @act41 need_reschedule ≔ TRUE&#10;      @act42 current_process_flag ≔ FALSE&#10;  end&#10;&#10;  event periodicprocess_finished extends process_finished&#10;    where&#10;      @grd40 current_partition_flag = TRUE ∧ current_process_flag = TRUE&#10;      @grd41 part = current_partition&#10;      @grd42 proc = current_process&#10;      @grd44 newstate = PS_Waiting&#10;      @grd45 period_of_process(proc) ≠ INFINITE_TIME_VALUE&#10;    then&#10;      @act41 need_reschedule ≔ TRUE&#10;      //@act42 releasepoint_of_process(proc) ≔  releasepoint_of_process(proc) + timecapacity_of_process(proc)&#10;      @act43 process_wait_type(proc) ≔ PROC_WAIT_PERIOD&#10;      @act44 current_process_flag ≔ FALSE&#10;  end&#10;&#10;  event time_out extends time_out&#10;    any time// time is the absolute time ,not the &quot;timeout&quot;&#10;&#10;    where&#10;&#10;      @grd41 proc ∈ dom(timeout_trigger)&#10;      @grd42 newstate ↦ time = timeout_trigger(proc)&#10;      //@grd43 process_state(proc) = PS_Waiting&#10;      @grd44 time ≥ (clock_tick − 1)∗ONE_TICK_TIME ∧ time ≤ clock_tick∗ONE_TICK_TIME // when the end time is ellapsed one tick&#10;      //@grd45 state = newstate&#10;    then&#10;      @act41 timeout_trigger ≔ timeout_trigger ∖{proc↦(newstate↦time)}&#10;      @act42 process_wait_type ≔  {proc} ⩤ process_wait_type&#10;  end&#10;&#10;  event req_busy_resource extends req_busy_resource&#10;  any wt timeout tmout_trig&#10;  where&#10;    @grd40 current_partition_flag = TRUE ∧ current_process_flag = TRUE&#10;    @grd41 part = current_partition&#10;    @grd42 proc = current_process&#10;    @grd43 wt∈PROCESS_WAIT_TYPES ∧ (wt= PROC_WAIT_OBJ ∨ wt=PROC_WAIT_TIMEOUT)&#10;    //@grd06 tmout &gt;0 ∨ tmout = INFINITE_TIME_VALUE&#10;    //this line is correct, the next line is from ARINC653&#10;    @grd44 timeout ≠0&#10;    @grd45 tmout_trig ∈ processes ⇸ (PROCESS_STATES × ℕ1)&#10;    @grd46 (timeout = INFINITE_TIME_VALUE ⇒  tmout_trig = ∅)&#10;    &#9;&#9;∧ (timeout ≠INFINITE_TIME_VALUE ⇒ tmout_trig = {proc↦(PS_Ready↦ (timeout +clock_tick ∗ ONE_TICK_TIME))})&#10;    @grd47 timeout≠INFINITE_TIME_VALUE ⇒ wt = PROC_WAIT_TIMEOUT&#10;    @grd48 timeout =  INFINITE_TIME_VALUE ⇒ wt = PROC_WAIT_OBJ&#10;&#10;  then&#10;    @act41 need_reschedule ≔ TRUE&#10;    @act42 current_process_flag ≔ FALSE&#10;    @act43 process_wait_type(proc) ≔ wt&#10;    @act05 timeout_trigger ≔ timeout_trigger   tmout_trig&#10;  end&#10;&#10;  event resource_become_available extends resource_become_available&#10;  any resch&#10;  where&#10;  &#9;@grd40 process_wait_type(proc)= PROC_WAIT_OBJ&#10;  &#9;@grd41 resch∈BOOL&#10;  then&#10;  &#9;@act41 process_wait_type ≔  {proc}⩤process_wait_type&#10;  &#9;@act42 timeout_trigger ≔ {proc}⩤timeout_trigger&#10;  &#9;@act43 need_reschedule ≔ resch&#10;  end&#10;&#10;  event resource_become_available2 extends resource_become_available2&#10;  any resch&#10;  where&#10;  &#9;@grd40 ∀proc·(proc∈procs ⇒ process_wait_type(proc)= PROC_WAIT_OBJ)&#10;  &#9;@grd41 resch∈BOOL&#10;  then&#10;  &#9;@act41 process_wait_type ≔  procs⩤process_wait_type&#10;  &#9;@act42 timeout_trigger ≔ procs⩤timeout_trigger&#10;  &#9;@act43 need_reschedule ≔ resch&#10;  end&#10;&#10;  event periodicproc_reach_releasepoint  //has already finished execution of this period.&#10;  extends periodicproc_reach_releasepoint&#10;  where&#10;      @grd11 period_of_process(proc) ≠ INFINITE_TIME_VALUE&#10;      @grd12 clock_tick∗ONE_TICK_TIME ≥ releasepoint_of_process(proc)&#10;      @grd13 process_state(proc) = PS_Waiting&#10;      @grd14 process_wait_type(proc) = PROC_WAIT_PERIOD&#10;  then&#10;  &#9;@act41 releasepoint_of_process(proc) ≔  releasepoint_of_process(proc) + period_of_process(proc)&#10;  &#9;@act42 deadlinetime_of_process(proc) ≔  releasepoint_of_process(proc) + timecapacity_of_process(proc)&#10;  end&#10;&#10;  event coldstart_partition_fromidle extends coldstart_partition_fromidle&#10;  then&#10;  &#9;@act401 locklevel_of_partition(part) ≔ 1&#10;  end&#10;&#10;  event warmstart_partition_fromidle extends warmstart_partition_fromidle&#10;  then&#10;  &#9;@act401 locklevel_of_partition(part) ≔ 1&#10;  end&#10;end&#10;" version="5">
<org.eventb.core.refinesMachine name="_QOB9INHVEeOO1v6vzqtXww" org.eventb.core.target="Mach_PartProc_Trans_with_Events"/>
<org.eventb.core.seesContext name="_g3sEEM4REeO_w8hSz1RRkQ" org.eventb.core.target="Ctx_PartProc_Manage"/>
<org.eventb.core.event name="'" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="INITIALISATION">
<org.eventb.core.action name="_PQkmMNJgEeOIk6vzYQGQiQ" org.eventb.core.assignment="process_wait_type ≔ ∅" org.eventb.core.label="act100"/>
<org.eventb.core.action name="_f-5NsM57EeOj2-yVf9avbQ" org.eventb.core.assignment="locklevel_of_partition ≔ PARTITIONS × {1}" org.eventb.core.label="act10"/>
<org.eventb.core.action name="_I8WFQM4REeO_w8hSz1RRkQ" org.eventb.core.assignment="startcondition_of_partition ≔  ∅" org.eventb.core.comment="@act121 schedulable_of_partition ≔  PARTITIONS × {FALSE}" org.eventb.core.label="act12"/>
<org.eventb.core.action name="_I8WFQc4REeO_w8hSz1RRkQ" org.eventb.core.assignment="basepriority_of_process ≔ ∅" org.eventb.core.label="act13"/>
<org.eventb.core.action name="_I8WFRM4REeO_w8hSz1RRkQ" org.eventb.core.assignment="period_of_process ≔  ∅" org.eventb.core.label="act14"/>
<org.eventb.core.action name="_I8WFRc4REeO_w8hSz1RRkQ" org.eventb.core.assignment="timecapacity_of_process ≔  ∅" org.eventb.core.label="act15"/>
<org.eventb.core.action name="_I8WFTc4REeO_w8hSz1RRkQ" org.eventb.core.assignment="deadline_of_process ≔  ∅" org.eventb.core.label="act16"/>
<org.eventb.core.action name="_I8WFTs4REeO_w8hSz1RRkQ" org.eventb.core.assignment="currentpriority_of_process ≔  ∅" org.eventb.core.label="act17"/>
<org.eventb.core.action name="_I8WFT84REeO_w8hSz1RRkQ" org.eventb.core.assignment="deadlinetime_of_process ≔  ∅" org.eventb.core.label="act18"/>
<org.eventb.core.action name="_I8WFQs4REeO_w8hSz1RRkQ" org.eventb.core.assignment="releasepoint_of_process ≔ ∅" org.eventb.core.comment="@act20 nextreleasepoint_of_process ≔ ∅" org.eventb.core.label="act19"/>
<org.eventb.core.action name="_TE9TcNKEEeOIk6vzYQGQiQ" org.eventb.core.assignment="delaytime_of_process ≔ ∅" org.eventb.core.label="act200"/>
<org.eventb.core.action name="_I8WFR84REeO_w8hSz1RRkQ" org.eventb.core.assignment="current_partition_flag ≔ FALSE" org.eventb.core.label="act21"/>
<org.eventb.core.action name="_f-5Nss57EeOj2-yVf9avbQ" org.eventb.core.assignment="current_process_flag ≔ FALSE" org.eventb.core.label="act22"/>
<org.eventb.core.action name="_f-5Ns857EeOj2-yVf9avbQ" org.eventb.core.assignment="current_partition :∈ PARTITIONS" org.eventb.core.label="act23"/>
<org.eventb.core.action name="_f-5NtM57EeOj2-yVf9avbQ" org.eventb.core.assignment="current_process :∈ PROCESSES" org.eventb.core.label="act24"/>
<org.eventb.core.action name="_f-5Ntc57EeOj2-yVf9avbQ" org.eventb.core.assignment="clock_tick ≔ 1" org.eventb.core.label="act25"/>
<org.eventb.core.action name="_f-5Nts57EeOj2-yVf9avbQ" org.eventb.core.assignment="need_reschedule ≔  FALSE" org.eventb.core.label="act26"/>
<org.eventb.core.action name="_bJOH8DKDEeSQ7c4olNszIw" org.eventb.core.assignment="need_procresch ≔ FALSE" org.eventb.core.label="act28"/>
<org.eventb.core.action name="_3_1gENdAEeOuG80hxTAROw" org.eventb.core.assignment="preempter_of_partition ≔ ∅" org.eventb.core.comment="@act17 remain_timecapacity_of_process ≔  ∅&#10;         @act18 wakeuptime_of_process ≔  ∅&#10;         @act_asgn_preemption preemption_of_partitions ≔ PARTITIONS × {TRUE} " org.eventb.core.label="act27"/>
<org.eventb.core.action name="_I8WFUc4REeO_w8hSz1RRkQ" org.eventb.core.assignment="timeout_trigger ≔ ∅" org.eventb.core.label="act_asgn_tmouttrig"/>
<org.eventb.core.action name="_I8WFUs4REeO_w8hSz1RRkQ" org.eventb.core.assignment="errorhandler_of_partition ≔ ∅" org.eventb.core.label="act_asgn_errhdlofpart"/>
<org.eventb.core.action name="_I8WFU84REeO_w8hSz1RRkQ" org.eventb.core.assignment="process_call_errorhandler ≔ ∅" org.eventb.core.label="act_process_call_errorhandler"/>
</org.eventb.core.event>
<org.eventb.core.variable name="_jWXXUM2gEeO_w8hSz1RRkQ" org.eventb.core.identifier="processes"/>
<org.eventb.core.variable name="_jWXXU82gEeO_w8hSz1RRkQ" org.eventb.core.identifier="processes_of_partition"/>
<org.eventb.core.variable name="_jWXXUc2gEeO_w8hSz1RRkQ" org.eventb.core.identifier="partition_mode"/>
<org.eventb.core.variable name="_jWXXUs2gEeO_w8hSz1RRkQ" org.eventb.core.identifier="process_state"/>
<org.eventb.core.variable name="_2qSDwNUOEeOE_q1ibjWlpA" org.eventb.core.comment="process_ids //all created processes which have the ID. error handler does not has ID" org.eventb.core.identifier="periodtype_of_process"/>
<org.eventb.core.variable name="_Owm1ENJSEeOIk6vzYQGQiQ" org.eventb.core.comment="mainproc_of_partition // the only one main proc of each partition" org.eventb.core.identifier="process_wait_type"/>
<org.eventb.core.variable name="_jWXXWs2gEeO_w8hSz1RRkQ" org.eventb.core.comment="denotes the current lock level of the partition&#10;             preemption_of_partitions " org.eventb.core.identifier="locklevel_of_partition"/>
<org.eventb.core.variable name="_jWXXW82gEeO_w8hSz1RRkQ" org.eventb.core.comment="denotes the reason the partition is started&#10;             schedulable_of_partition //the scheduling of a partition is activated or disactivated? " org.eventb.core.identifier="startcondition_of_partition"/>
<org.eventb.core.variable name="_jWXXXM2gEeO_w8hSz1RRkQ" org.eventb.core.comment="Denotes the capability of the process to manipulate other processes." org.eventb.core.identifier="basepriority_of_process"/>
<org.eventb.core.variable name="_jWXXXc2gEeO_w8hSz1RRkQ" org.eventb.core.comment="Identifies the period of activation for a periodic process. A distinct and unique value should be specified to designate the process as aperiodic" org.eventb.core.identifier="period_of_process"/>
<org.eventb.core.variable name="_jWXXXs2gEeO_w8hSz1RRkQ" org.eventb.core.comment="Defines the elapsed time within which the process should complete its execution." org.eventb.core.identifier="timecapacity_of_process"/>
<org.eventb.core.variable name="_jWXXX82gEeO_w8hSz1RRkQ" org.eventb.core.comment="Specifies the type of deadline relating to the process, and may be “hard” or “soft”." org.eventb.core.identifier="deadline_of_process"/>
<org.eventb.core.variable name="_jWXXYM2gEeO_w8hSz1RRkQ" org.eventb.core.comment="Defines the priority with which the process may access and receive resources. It is set to base priority at initialization time and is dynamic at runtime." org.eventb.core.identifier="currentpriority_of_process"/>
<org.eventb.core.variable name="_jWXXYc2gEeO_w8hSz1RRkQ" org.eventb.core.comment="The deadline time is periodically evaluated by the operating system to determine whether the process is satisfactorily completing its processing within the allotted time." org.eventb.core.identifier="deadlinetime_of_process"/>
<org.eventb.core.variable name="_jWXXYs2gEeO_w8hSz1RRkQ" org.eventb.core.comment="the release point of processes&#10;             nextreleasepoint_of_process // the next release point of processes " org.eventb.core.identifier="releasepoint_of_process"/>
<org.eventb.core.variable name="_4iW-gNKDEeOIk6vzYQGQiQ" org.eventb.core.comment="if the proc is delayed started, the delaytime should be saved(used when parttion START --&gt; NORMAL)" org.eventb.core.identifier="delaytime_of_process"/>
<org.eventb.core.variable name="_jWXXVM2gEeO_w8hSz1RRkQ" org.eventb.core.comment="the partition in which a thread is now running. at each time, only one thread is running" org.eventb.core.identifier="current_partition"/>
<org.eventb.core.variable name="_jWXXVc2gEeO_w8hSz1RRkQ" org.eventb.core.identifier="current_process"/>
<org.eventb.core.variable name="_jWXXVs2gEeO_w8hSz1RRkQ" org.eventb.core.comment="true:indicate that the current_partition is valid, false: indicate NULL (unavailable)" org.eventb.core.identifier="current_partition_flag"/>
<org.eventb.core.variable name="_jWXXV82gEeO_w8hSz1RRkQ" org.eventb.core.comment="same as current partition flag" org.eventb.core.identifier="current_process_flag"/>
<org.eventb.core.variable name="_jWXXWM2gEeO_w8hSz1RRkQ" org.eventb.core.comment="system clock ticks" org.eventb.core.identifier="clock_tick"/>
<org.eventb.core.variable name="_jWXXWc2gEeO_w8hSz1RRkQ" org.eventb.core.comment="indicate the flag to reschedule after some events, for example suspend a thread" org.eventb.core.identifier="need_reschedule"/>
<org.eventb.core.variable name="_bJRyUDKDEeSQ7c4olNszIw" org.eventb.core.comment="after partition scheduling, trigger the process level scheduling" org.eventb.core.identifier="need_procresch"/>
<org.eventb.core.variable name="_3__RENdAEeOuG80hxTAROw" org.eventb.core.comment="the process who execute the lock_preemption (increase the locklevel and disable scheduling), at most one preempter proc in a partition" org.eventb.core.identifier="preempter_of_partition"/>
<org.eventb.core.variable name="_jWXXZc2gEeO_w8hSz1RRkQ" org.eventb.core.comment="all processes waiting for resources with a timeout, will be triggered after the timeout ellapsed." org.eventb.core.identifier="timeout_trigger"/>
<org.eventb.core.variable name="_jWXXZs2gEeO_w8hSz1RRkQ" org.eventb.core.comment="each partition has one error handler at most. other error handler can be created only after the previous handler is finished" org.eventb.core.identifier="errorhandler_of_partition"/>
<org.eventb.core.variable name="_jWXXZ82gEeO_w8hSz1RRkQ" org.eventb.core.comment="error handler is created by a process, then the process is preempted by the error handler" org.eventb.core.identifier="process_call_errorhandler"/>
<org.eventb.core.invariant name="_EWjvsNJgEeOIk6vzYQGQiQ" org.eventb.core.comment="partial function, only if the process is in WAITING" org.eventb.core.label="inv_process_wait_type" org.eventb.core.predicate="process_wait_type ∈ processes ⇸ PROCESS_WAIT_TYPES"/>
<org.eventb.core.invariant name="_FX3R4NfVEeOie6XboyvqsA" org.eventb.core.label="inv_proc_waittype2" org.eventb.core.predicate="∀p·(p∈processes ∧ (process_state(p)=PS_Waiting ∨ process_state(p)=PS_WaitandSuspend)⇒p∈dom(process_wait_type))"/>
<org.eventb.core.invariant name="_ngh_y82iEeO_w8hSz1RRkQ" org.eventb.core.label="inv_locklevel" org.eventb.core.predicate="locklevel_of_partition ∈ PARTITIONS → ℕ"/>
<org.eventb.core.invariant name="_ngh_zM2iEeO_w8hSz1RRkQ" org.eventb.core.label="inv_start_condition" org.eventb.core.predicate="startcondition_of_partition ∈ PARTITIONS ⇸ PARTITION_STARTCONDITIONS"/>
<org.eventb.core.invariant name="_U9QPkNM5EeOzJJnArOuL7g" org.eventb.core.label="inv_start_imply_locklevel" org.eventb.core.predicate="∀p·(p∈PARTITIONS∧(partition_mode(p)=PM_COLD_START ∨ partition_mode(p)=PM_WARM_START) ⇒locklevel_of_partition(p)&gt;0)"/>
<org.eventb.core.invariant name="_43iDUNPuEeOZBrbXix_W6g" org.eventb.core.comment="we do not consider the time&#10;@inv_partperiod_greatest_common_factor_procperiod&#10;∀p·(p∈processes ∧ period_of_process(p) ≠INFINITE_TIME_VALUE ⇒  (∃n·(n∈ℕ1 ∧ Period_of_Partition(processes_of_partition(p))∗n=period_of_process(p)))) // the partition period is the greatest common factor （最大公因数）of the process periods within a partition&#10;@inv_timcap_lessthen_period ∀p·(p∈processes ∧ period_of_process(p) ≠INFINITE_TIME_VALUE ⇒ timecapacity_of_process(p) &lt; period_of_process(p))" org.eventb.core.label="inv_locklevel0_imply_normal" org.eventb.core.predicate="∀p·(p∈PARTITIONS ∧ locklevel_of_partition(p)=0 ⇒ partition_mode(p)=PM_NORMAL)"/>
<org.eventb.core.invariant name="_K9dKUM5yEeOj2-yVf9avbQ" org.eventb.core.label="inv_basepriority_processes" org.eventb.core.predicate="basepriority_of_process ∈ processes → MIN_PRIORITY_VALUE‥MAX_PRIORITY_VALUE"/>
<org.eventb.core.invariant name="_K9dKUc5yEeOj2-yVf9avbQ" org.eventb.core.comment="infinite(-1) means aperiodic" org.eventb.core.label="inv_period_processes" org.eventb.core.predicate="period_of_process ∈ processes → ℤ"/>
<org.eventb.core.invariant name="_K9dKUs5yEeOj2-yVf9avbQ" org.eventb.core.comment="infinite(-1) means no deadline time" org.eventb.core.label="inv_timecapacity_processes" org.eventb.core.predicate="timecapacity_of_process ∈ processes → ℤ"/>
<org.eventb.core.invariant name="_K9dKU85yEeOj2-yVf9avbQ" org.eventb.core.label="inv_deadline_processes" org.eventb.core.predicate="deadline_of_process ∈ processes → DEADLINE_TYPE"/>
<org.eventb.core.invariant name="_K9dKVM5yEeOj2-yVf9avbQ" org.eventb.core.label="inv_currentpriority_processes" org.eventb.core.predicate="currentpriority_of_process ∈ processes → MIN_PRIORITY_VALUE‥MAX_PRIORITY_VALUE"/>
<org.eventb.core.invariant name="_K9dKVc5yEeOj2-yVf9avbQ" org.eventb.core.label="inv_deadlinetime_processes" org.eventb.core.predicate="deadlinetime_of_process ∈ processes ⇸ ℕ"/>
<org.eventb.core.invariant name="_ngh_082iEeO_w8hSz1RRkQ" org.eventb.core.comment="@inv_nextreleasepoint_of_process nextreleasepoint_of_process ∈ processes ⇸ ℕ" org.eventb.core.label="inv_releasepoint_of_process" org.eventb.core.predicate="releasepoint_of_process ∈ processes ⇸ ℕ"/>
<org.eventb.core.invariant name="_OG3o0NKEEeOIk6vzYQGQiQ" org.eventb.core.label="inv_delaytime_of_process" org.eventb.core.predicate="delaytime_of_process ∈ processes ⇸ ℕ"/>
<org.eventb.core.invariant name="_5Xnv8NfQEeOie6XboyvqsA" org.eventb.core.label="inv_delaytime2" org.eventb.core.predicate="∀p·(p∈processes ∧ partition_mode(processes_of_partition(p))=PM_NORMAL ∧ process_state(p)=PS_Waiting ∧ process_wait_type(p)=PROC_WAIT_DELAY ⇒ p∈dom(delaytime_of_process) )"/>
<org.eventb.core.invariant name="_Ve-PkNY5EeOfRqI26w1WvQ" org.eventb.core.label="inv_periodtype1" org.eventb.core.predicate="∀p·(p∈processes ⇒(periodtype_of_process(p)=APERIOD_PROC⇔ period_of_process(p)=INFINITE_TIME_VALUE))"/>
<org.eventb.core.invariant name="_Ve-PkdY5EeOfRqI26w1WvQ" org.eventb.core.comment="partial func. if the process was delayed started, the &lt;process--&gt;delaytime&gt; is in this var&#10;     @inv_remain_timecapacity_threads remain_timecapacity_of_process ∈ processes → ℕ&#10;     @inv_wakeuptime_threads wakeuptime_of_process ∈ processes → ℕ&#10;     @inv_system_started system_has_inited ∈ BOOL " org.eventb.core.label="inv_periodtype2" org.eventb.core.predicate="∀p·(p∈processes ⇒(periodtype_of_process(p)=PERIOD_PROC⇔ period_of_process(p)≠INFINITE_TIME_VALUE))"/>
<org.eventb.core.invariant name="_ngh_wM2iEeO_w8hSz1RRkQ" org.eventb.core.label="inv_curpart" org.eventb.core.predicate="current_partition ∈ PARTITIONS"/>
<org.eventb.core.invariant name="_ngh_wc2iEeO_w8hSz1RRkQ" org.eventb.core.label="inv_curpart_flag" org.eventb.core.predicate="current_partition_flag ∈ BOOL"/>
<org.eventb.core.invariant name="_ngh_ws2iEeO_w8hSz1RRkQ" org.eventb.core.label="inv_curproc_flag" org.eventb.core.predicate="current_process_flag ∈ BOOL"/>
<org.eventb.core.invariant name="_ngh_xM2iEeO_w8hSz1RRkQ" org.eventb.core.label="inv_curproc" org.eventb.core.predicate="(current_process_flag = TRUE ⇒  current_process ∈ processes)"/>
<org.eventb.core.invariant name="_ngh_xc2iEeO_w8hSz1RRkQ" org.eventb.core.label="inv_curprocimplycurpart" org.eventb.core.predicate="current_process_flag = TRUE ⇒ current_partition_flag = TRUE"/>
<org.eventb.core.invariant name="_ngh_xs2iEeO_w8hSz1RRkQ" org.eventb.core.label="inv_cur_proc_part" org.eventb.core.predicate="(current_process_flag = TRUE ∧ current_partition_flag = TRUE ⇒ processes_of_partition(current_process) = current_partition)"/>
<org.eventb.core.invariant name="_ngh_x82iEeO_w8hSz1RRkQ" org.eventb.core.label="inv_partstate_curr" org.eventb.core.predicate="(current_partition_flag = TRUE ⇒ partition_mode(current_partition) ≠ PM_IDLE)"/>
<org.eventb.core.invariant name="_ngh_yM2iEeO_w8hSz1RRkQ" org.eventb.core.comment="@glue_proc_states_dormant ∀proc·(proc∈processes ⇒ (process_state_r(proc) = PS_Dormant ⇔ process_state(proc) = TS_Dormant ))&#10;     @glue_proc_states_ready ∀proc·(proc∈processes ⇒ (process_state_r(proc) = PS_Ready ⇔ process_state(proc) = TS_Ready ))&#10;     @glue_proc_states_running ∀proc·(proc∈processes ⇒ (process_state_r(proc) = PS_Running ⇔ process_state(proc) = TS_Running))&#10;     @glue_proc_states_waiting ∀proc·(proc∈processes ⇒ ((process_state_r(proc) = PS_Waiting ∨ process_state_r(proc) = PS_Suspend ∨ process_state_r(proc) = PS_WaitandSuspend)⇔ process_state(proc) = TS_Waiting )) " org.eventb.core.label="inv_procstate_curr" org.eventb.core.predicate="(current_process_flag = TRUE ⇒ process_state(current_process) = PS_Running ∧ partition_mode(current_partition)=PM_NORMAL)"/>
<org.eventb.core.invariant name="_ngh_yc2iEeO_w8hSz1RRkQ" org.eventb.core.label="inv_clocktick" org.eventb.core.predicate="clock_tick ∈ ℕ"/>
<org.eventb.core.invariant name="_ngh_ys2iEeO_w8hSz1RRkQ" org.eventb.core.comment="@inv_preemption preemption_of_partitions ∈ PARTITIONS → BOOL" org.eventb.core.label="inv_need_reschedule" org.eventb.core.predicate="need_reschedule ∈ BOOL"/>
<org.eventb.core.invariant name="_bJYgADKDEeSQ7c4olNszIw" org.eventb.core.label="inv_need_procresch" org.eventb.core.predicate="need_procresch∈BOOL"/>
<org.eventb.core.invariant name="_3__REddAEeOuG80hxTAROw" org.eventb.core.comment="partial injection." org.eventb.core.label="inv_preempter_of_partition" org.eventb.core.predicate="preempter_of_partition ∈PARTITIONS ⤔ processes"/>
<org.eventb.core.invariant name="_FbVY0TJ7EeSQ7c4olNszIw" org.eventb.core.label="inv_locklevel_imply_preempter" org.eventb.core.predicate="∀p·(p∈PARTITIONS ∧ partition_mode(p)=PM_NORMAL ∧ locklevel_of_partition(p) &gt; 0 ⇒  p∈dom(preempter_of_partition))"/>
<org.eventb.core.invariant name="_rwpG0DJ7EeSQ7c4olNszIw" org.eventb.core.comment="@inv_preemption_locklevel ∀p·(p∈PARTITIONS ⇒ ((locklevel_of_partition(p) &gt; 0 ⇔ preemption_of_partitions(p) = FALSE)&#10;     ∧ (locklevel_of_partition(p) = 0 ⇔ preemption_of_partitions(p) = TRUE))) " org.eventb.core.label="inv_locklevel_imply_preempter2" org.eventb.core.predicate="∀p·(p∈PARTITIONS ∧ partition_mode(p)=PM_NORMAL ∧ p∈dom(preempter_of_partition) ⇒ locklevel_of_partition(p) &gt; 0 )"/>
<org.eventb.core.invariant name="_ngh_182iEeO_w8hSz1RRkQ" org.eventb.core.comment="a process waiting for some resource with a timeout and will be transitted to another state" org.eventb.core.label="inv_tmout_trig_type" org.eventb.core.predicate="timeout_trigger∈processes ⇸ (PROCESS_STATES × ℕ1)"/>
<org.eventb.core.invariant name="_ngh_2M2iEeO_w8hSz1RRkQ" org.eventb.core.comment="@inv_tmout_trig_nextstate dom(ran(timeout_trigger)) = {PS_Ready} // in the kernel, in fact, the next state when time out is always READY" org.eventb.core.label="inv_tmout_trig_state" org.eventb.core.predicate="∀p·(p∈dom(timeout_trigger) ⇒ (process_state(p) = PS_Waiting ∨ process_state(p) = PS_WaitandSuspend ∨ process_state(p) = PS_Suspend))"/>
<org.eventb.core.invariant name="_ngh_2c2iEeO_w8hSz1RRkQ" org.eventb.core.comment="partial injection. a partition has one handler at most, when error happens" org.eventb.core.label="inv_errhandler_partition" org.eventb.core.predicate="errorhandler_of_partition ∈ PARTITIONS ⤔ processes"/>
<org.eventb.core.invariant name="_ngh_2s2iEeO_w8hSz1RRkQ" org.eventb.core.label="inv_errhandler_has_maxpriority" org.eventb.core.predicate="∀p·(p∈ran(errorhandler_of_partition) ⇒  (p∈dom(currentpriority_of_process) ⇒ currentpriority_of_process(p) = MAX_PRIORITY_VALUE))"/>
<org.eventb.core.invariant name="_ngh_282iEeO_w8hSz1RRkQ" org.eventb.core.comment="@inv_atmostoneerrhandler_inpartition ∀p·(p∈processes ⇒ card(errorhandler_of_partition∼[{p}]) ≤ 1) // an error handler only belongs to a partition" org.eventb.core.label="inv_errhandler_inpartition" org.eventb.core.predicate="∀part,p·(part↦p ∈ errorhandler_of_partition ⇒  processes_of_partition(p) = part)"/>
<org.eventb.core.invariant name="_ngrwwM2iEeO_w8hSz1RRkQ" org.eventb.core.comment="partial injection" org.eventb.core.label="inv_process_call_errorhandler" org.eventb.core.predicate="process_call_errorhandler ∈ processes ⤔ processes"/>
<org.eventb.core.invariant name="_ngrwwc2iEeO_w8hSz1RRkQ" org.eventb.core.comment="error handler and its creator process is in same partition" org.eventb.core.label="inv_errhandlerandcaller_insamepart" org.eventb.core.predicate="∀p1,p2·(p1 ↦ p2 ∈ process_call_errorhandler ⇒ processes_of_partition(p1)= processes_of_partition(p2))"/>
<org.eventb.core.invariant name="_ngrwws2iEeO_w8hSz1RRkQ" org.eventb.core.comment="each error handler, this the only one caller" org.eventb.core.label="inv_from_errhandler_to_caller" org.eventb.core.predicate="dom(process_call_errorhandler) = ran(errorhandler_of_partition) ∧ ran(process_call_errorhandler) ⊆ processes ∖ran(errorhandler_of_partition)"/>
<org.eventb.core.event name="_fAEk8NJgEeOIk6vzYQGQiQ" org.eventb.core.comment="timer interrupt event, triggered by the timer in hardware. one tick in each ONE_TICK_TIME" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ticktock">
<org.eventb.core.action name="_fAFMANJgEeOIk6vzYQGQiQ" org.eventb.core.assignment="clock_tick ≔ clock_tick + 1" org.eventb.core.label="act01"/>
<org.eventb.core.action name="_fAFMAdJgEeOIk6vzYQGQiQ" org.eventb.core.assignment="need_reschedule ≔ TRUE" org.eventb.core.label="act02"/>
</org.eventb.core.event>
<org.eventb.core.event name="__hAp8NcpEeOuG80hxTAROw" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="partition_schedule">
<org.eventb.core.refinesEvent name="__hAp8dcpEeOuG80hxTAROw" org.eventb.core.target="partition_schedule"/>
<org.eventb.core.parameter name="_aTNs4ddFEeOuG80hxTAROw" org.eventb.core.comment="current time is in one partition window?" org.eventb.core.identifier="found"/>
<org.eventb.core.guard name="__hAp8tcpEeOuG80hxTAROw" org.eventb.core.label="grd10" org.eventb.core.predicate="need_reschedule = TRUE"/>
<org.eventb.core.guard name="__hAp89cpEeOuG80hxTAROw" org.eventb.core.comment="the next two line are commented by the reason that ARINC653 does not implement the scheduling" org.eventb.core.label="grd11" org.eventb.core.predicate="found ∈ BOOL"/>
<org.eventb.core.guard name="_AiqNgDVLEeSxw-wt7-_VGQ" org.eventb.core.label="grd12" org.eventb.core.predicate="∃x,y,b,n·(((x↦y)↦b) ∈ partitionTimeWindows ∧ timeWindowsofPartition((x↦y)↦b) = part ∧&#10;            (x + n∗majorFrame) &lt; clock_tick∗ONE_TICK_TIME ∧ clock_tick∗ONE_TICK_TIME &lt; (x +y + n∗majorFrame)) ⇒found=TRUE"/>
<org.eventb.core.guard name="_AiqNgTVLEeSxw-wt7-_VGQ" org.eventb.core.label="grd13" org.eventb.core.predicate="¬(∃x,y,b,n·(((x↦y)↦b) ∈ partitionTimeWindows ∧ timeWindowsofPartition((x↦y)↦b) = part ∧&#10;            (x + n∗majorFrame) &lt; clock_tick∗ONE_TICK_TIME ∧ clock_tick∗ONE_TICK_TIME &lt; (x +y + n∗majorFrame))) ⇒found=FALSE"/>
<org.eventb.core.action name="__hAp9NcpEeOuG80hxTAROw" org.eventb.core.assignment="current_partition_flag ≔ found" org.eventb.core.label="act11"/>
<org.eventb.core.action name="__hAp9dcpEeOuG80hxTAROw" org.eventb.core.assignment="current_partition ≔ part" org.eventb.core.comment="if flag is FALSE, the assign is arbitrary" org.eventb.core.label="act12"/>
<org.eventb.core.action name="_Dep6sNdrEeOLOKxWN32dmQ" org.eventb.core.assignment="current_process_flag ≔ FALSE" org.eventb.core.label="act13"/>
<org.eventb.core.action name="_xY5rATVIEeSxw-wt7-_VGQ" org.eventb.core.assignment="need_procresch :∣ ((partition_mode(part) = PM_NORMAL) ⇒ need_procresch' = TRUE) ∧ ((partition_mode(part) = PM_COLD_START ∨ partition_mode(part) = PM_WARM_START) ⇒ need_procresch' = FALSE )" org.eventb.core.label="act14"/>
<org.eventb.core.action name="_YQGlIDVJEeSxw-wt7-_VGQ" org.eventb.core.assignment="need_reschedule :∣ ((partition_mode(part) = PM_NORMAL) ⇒ need_reschedule' = FALSE) ∧ ((partition_mode(part) = PM_COLD_START ∨ partition_mode(part) = PM_WARM_START) ⇒ need_reschedule' = TRUE )" org.eventb.core.label="act15"/>
</org.eventb.core.event>
<org.eventb.core.event name="_USaykNWZEeOBH5daWkgzeQ" org.eventb.core.comment="if there is not error handler and preempter in this partition" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="process_schedule">
<org.eventb.core.refinesEvent name="_USaykdWZEeOBH5daWkgzeQ" org.eventb.core.target="process_schedule"/>
<org.eventb.core.guard name="_sbMdYNcuEeOuG80hxTAROw" org.eventb.core.label="grd10" org.eventb.core.predicate="need_procresch = TRUE"/>
<org.eventb.core.guard name="_aTNs5NdFEeOuG80hxTAROw" org.eventb.core.label="grd11" org.eventb.core.predicate="current_partition_flag = TRUE ∧ current_partition = part"/>
<org.eventb.core.guard name="_aTNs5ddFEeOuG80hxTAROw" org.eventb.core.comment="current_partition∉dom(preempter_of_partition)" org.eventb.core.label="grd12" org.eventb.core.predicate="(current_partition∉dom(errorhandler_of_partition) ∨ process_state(errorhandler_of_partition(current_partition))=PS_Dormant) ∧ locklevel_of_partition(current_partition) = 0"/>
<org.eventb.core.guard name="_qj6EwStmEeSCDLsjAFWqoQ" org.eventb.core.label="grd13" org.eventb.core.predicate="∀p·(p∈processes_of_partition∼[{part}] ⇒ currentpriority_of_process(p) ≤ currentpriority_of_process(proc))"/>
<org.eventb.core.action name="_sbMdYtcuEeOuG80hxTAROw" org.eventb.core.assignment="current_process ≔ proc" org.eventb.core.label="act22"/>
<org.eventb.core.action name="_sbMdZNcuEeOuG80hxTAROw" org.eventb.core.assignment="current_process_flag ≔ TRUE" org.eventb.core.label="act24"/>
<org.eventb.core.action name="_sbMdZdcuEeOuG80hxTAROw" org.eventb.core.assignment="need_reschedule ≔ FALSE" org.eventb.core.label="act25"/>
<org.eventb.core.action name="_bJfNsDKDEeSQ7c4olNszIw" org.eventb.core.assignment="need_procresch ≔ FALSE" org.eventb.core.label="act26"/>
</org.eventb.core.event>
<org.eventb.core.event name="_T-ZXsNd4EeOlhKj5h8QZMw" org.eventb.core.comment="if there is the error handler, it is executed, otherwise the preempter is executed" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="run_errorhandler_preempter">
<org.eventb.core.refinesEvent name="_g3ZM8NeEEeOCX_cGGZTAxg" org.eventb.core.target="process_schedule"/>
<org.eventb.core.guard name="_KvT7gdeEEeOCX_cGGZTAxg" org.eventb.core.label="grd30" org.eventb.core.predicate="need_procresch = TRUE"/>
<org.eventb.core.guard name="_KvT7gteEEeOCX_cGGZTAxg" org.eventb.core.label="grd31" org.eventb.core.predicate="current_partition_flag = TRUE ∧ current_partition = part"/>
<org.eventb.core.guard name="_KvT7g9eEEeOCX_cGGZTAxg" org.eventb.core.comment="current_partition∈dom(preempter_of_partition)" org.eventb.core.label="grd32" org.eventb.core.predicate="(current_partition∈dom(errorhandler_of_partition) ∧process_state(errorhandler_of_partition(current_partition))≠PS_Dormant) ∨ locklevel_of_partition(current_partition) &gt; 0"/>
<org.eventb.core.guard name="_KvT7hNeEEeOCX_cGGZTAxg" org.eventb.core.label="grd33" org.eventb.core.predicate="current_partition∈dom(errorhandler_of_partition) ⇒ proc = errorhandler_of_partition(current_partition)"/>
<org.eventb.core.guard name="_KvT7hdeEEeOCX_cGGZTAxg" org.eventb.core.label="grd34" org.eventb.core.predicate="current_partition∉dom(errorhandler_of_partition) ∧ locklevel_of_partition(current_partition) &gt; 0 ⇒ proc = preempter_of_partition(current_partition)"/>
<org.eventb.core.action name="_T-ZXuNd4EeOlhKj5h8QZMw" org.eventb.core.assignment="current_process ≔ proc" org.eventb.core.label="act22"/>
<org.eventb.core.action name="_T-ZXudd4EeOlhKj5h8QZMw" org.eventb.core.assignment="current_process_flag ≔ TRUE" org.eventb.core.comment="@act26 process_state(proc) ≔ PS_Running" org.eventb.core.label="act24"/>
<org.eventb.core.action name="_T-ZXutd4EeOlhKj5h8QZMw" org.eventb.core.assignment="need_reschedule ≔ FALSE" org.eventb.core.label="act25"/>
<org.eventb.core.action name="_bJiRADKDEeSQ7c4olNszIw" org.eventb.core.assignment="need_procresch ≔ FALSE" org.eventb.core.label="act26"/>
</org.eventb.core.event>
<org.eventb.core.event name="_R_8BcNGaEeOO1v6vzqtXww" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="get_partition_status">
<org.eventb.core.guard name="_R_8BcdGaEeOO1v6vzqtXww" org.eventb.core.label="grd01" org.eventb.core.predicate="current_partition_flag = TRUE"/>
</org.eventb.core.event>
<org.eventb.core.event name="_QyP9INHYEeOO1v6vzqtXww" org.eventb.core.comment="shutdown the partition" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="set_partition_mode_to_idle">
<org.eventb.core.refinesEvent name="_QyP9IdHYEeOO1v6vzqtXww" org.eventb.core.target="set_partition_mode_to_idle"/>
<org.eventb.core.guard name="_dKElANfkEeOuSP1sPLS_Hw" org.eventb.core.label="grd40" org.eventb.core.predicate="current_partition_flag = TRUE ∧ current_partition=part"/>
<org.eventb.core.action name="_vAVhkNJ2EeOIk6vzYQGQiQ" org.eventb.core.assignment="process_wait_type ≔ procs ⩤ process_wait_type" org.eventb.core.label="act401"/>
<org.eventb.core.action name="_vAVhkdJ2EeOIk6vzYQGQiQ" org.eventb.core.assignment="locklevel_of_partition(part) ≔ 1" org.eventb.core.comment="@act403 preemption_of_partitions(part) ≔ TRUE&#10;         @act404 startcondition_of_partition(part) ≔   NORMAL_START&#10;         @act404 schedulable_of_partition(part) ≔ FALSE " org.eventb.core.label="act402"/>
<org.eventb.core.action name="_vAVhk9J2EeOIk6vzYQGQiQ" org.eventb.core.assignment="basepriority_of_process ≔  procs ⩤ basepriority_of_process" org.eventb.core.label="act405"/>
<org.eventb.core.action name="_vAVhlNJ2EeOIk6vzYQGQiQ" org.eventb.core.assignment="period_of_process ≔   procs ⩤ period_of_process" org.eventb.core.label="act406"/>
<org.eventb.core.action name="_vAWIoNJ2EeOIk6vzYQGQiQ" org.eventb.core.assignment="timecapacity_of_process ≔   procs ⩤ timecapacity_of_process" org.eventb.core.label="act407"/>
<org.eventb.core.action name="_vAWIodJ2EeOIk6vzYQGQiQ" org.eventb.core.assignment="deadline_of_process ≔   procs ⩤ deadline_of_process" org.eventb.core.label="act408"/>
<org.eventb.core.action name="_vAWIotJ2EeOIk6vzYQGQiQ" org.eventb.core.assignment="currentpriority_of_process ≔   procs ⩤ currentpriority_of_process" org.eventb.core.label="act409"/>
<org.eventb.core.action name="_vAWIo9J2EeOIk6vzYQGQiQ" org.eventb.core.assignment="deadlinetime_of_process ≔   procs ⩤ deadlinetime_of_process" org.eventb.core.label="act410"/>
<org.eventb.core.action name="_vAWvsNJ2EeOIk6vzYQGQiQ" org.eventb.core.assignment="releasepoint_of_process ≔   procs ⩤ releasepoint_of_process" org.eventb.core.comment="@act412 nextreleasepoint_of_process ≔   procs ⩤ nextreleasepoint_of_process" org.eventb.core.label="act411"/>
<org.eventb.core.action name="_aZwWwNKEEeOIk6vzYQGQiQ" org.eventb.core.assignment="delaytime_of_process ≔ procs ⩤ delaytime_of_process" org.eventb.core.label="act413"/>
<org.eventb.core.action name="_F8TAANLEEeOIk6vzYQGQiQ" org.eventb.core.assignment="timeout_trigger ≔  procs ⩤ timeout_trigger" org.eventb.core.label="act414"/>
<org.eventb.core.action name="_F8TAAdLEEeOIk6vzYQGQiQ" org.eventb.core.assignment="errorhandler_of_partition ≔  {part} ⩤ errorhandler_of_partition" org.eventb.core.label="act415"/>
<org.eventb.core.action name="_F8TnENLEEeOIk6vzYQGQiQ" org.eventb.core.assignment="process_call_errorhandler ≔  procs ⩤ process_call_errorhandler" org.eventb.core.label="act416"/>
<org.eventb.core.action name="_nKeWMNckEeOuG80hxTAROw" org.eventb.core.assignment="current_partition_flag ≔ FALSE" org.eventb.core.label="act417"/>
<org.eventb.core.action name="_nKeWMdckEeOuG80hxTAROw" org.eventb.core.assignment="current_process_flag ≔ FALSE" org.eventb.core.label="act418"/>
<org.eventb.core.action name="_Ry9sMNfLEeOie6XboyvqsA" org.eventb.core.assignment="preempter_of_partition ≔  {part} ⩤ preempter_of_partition" org.eventb.core.label="act419"/>
</org.eventb.core.event>
<org.eventb.core.event name="_QyQkMNHYEeOO1v6vzqtXww" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="set_partition_mode_to_normal">
<org.eventb.core.refinesEvent name="_QyQkMdHYEeOO1v6vzqtXww" org.eventb.core.target="set_partition_mode_to_normal"/>
<org.eventb.core.parameter name="_ranskNLNEeOIk6vzYQGQiQ" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_cdSKkNLNEeOIk6vzYQGQiQ" org.eventb.core.identifier="procs"/>
<org.eventb.core.parameter name="_cdSKkdLNEeOIk6vzYQGQiQ" org.eventb.core.identifier="procs2"/>
<org.eventb.core.parameter name="_Ouct8NLLEeOIk6vzYQGQiQ" org.eventb.core.identifier="staperprocs"/>
<org.eventb.core.parameter name="_Ouct8dLLEeOIk6vzYQGQiQ" org.eventb.core.identifier="dstaperprocs"/>
<org.eventb.core.parameter name="_OudVANLLEeOIk6vzYQGQiQ" org.eventb.core.identifier="suspaperprocs"/>
<org.eventb.core.parameter name="_OudVAdLLEeOIk6vzYQGQiQ" org.eventb.core.identifier="stperprocs"/>
<org.eventb.core.parameter name="_OudVAtLLEeOIk6vzYQGQiQ" org.eventb.core.identifier="dstperprocs"/>
<org.eventb.core.parameter name="_xDf2ENLMEeOIk6vzYQGQiQ" org.eventb.core.identifier="rlt"/>
<org.eventb.core.parameter name="_9y-N0NLWEeOIk6vzYQGQiQ" org.eventb.core.identifier="nrlt1"/>
<org.eventb.core.parameter name="_9y-N0dLWEeOIk6vzYQGQiQ" org.eventb.core.identifier="nrlt2"/>
<org.eventb.core.parameter name="_xX2-4NfiEeOuSP1sPLS_Hw" org.eventb.core.identifier="newm"/>
<org.eventb.core.parameter name="_jr03INlrEeO0qb61sEhIIg" org.eventb.core.identifier="dl1"/>
<org.eventb.core.parameter name="_jr03IdlrEeO0qb61sEhIIg" org.eventb.core.identifier="dl2"/>
<org.eventb.core.parameter name="_jr03ItlrEeO0qb61sEhIIg" org.eventb.core.identifier="dl3"/>
<org.eventb.core.parameter name="_jr03I9lrEeO0qb61sEhIIg" org.eventb.core.identifier="dl4"/>
<org.eventb.core.guard name="_raoToNLNEeOIk6vzYQGQiQ" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS"/>
<org.eventb.core.guard name="_raoTodLNEeOIk6vzYQGQiQ" org.eventb.core.label="grd02" org.eventb.core.predicate="partition_mode(part) = PM_COLD_START ∨  partition_mode(part) = PM_WARM_START"/>
<org.eventb.core.guard name="_uqUIoNfkEeOuSP1sPLS_Hw" org.eventb.core.label="grd40" org.eventb.core.predicate="current_partition_flag = TRUE ∧ current_partition=part"/>
<org.eventb.core.guard name="_9Hc9ENfjEeOuSP1sPLS_Hw" org.eventb.core.label="grd08" org.eventb.core.predicate="card(processes_of_partition∼[{part}]) &gt; 0"/>
<org.eventb.core.guard name="_cdSxoNLNEeOIk6vzYQGQiQ" org.eventb.core.comment="transit to normal, some WAITING procs (aperiod, not suspended) will be transit to READY" org.eventb.core.label="grd09" org.eventb.core.predicate="procs =processes_of_partition∼[{part}] ∩ process_state∼[{PS_Waiting}]"/>
<org.eventb.core.guard name="_cdTYsNLNEeOIk6vzYQGQiQ" org.eventb.core.comment="transit to normal, the WAITandSuspend procs will be transit to suspend" org.eventb.core.label="grd10" org.eventb.core.predicate="procs2 = processes_of_partition∼[{part}] ∩ process_state∼[{PS_WaitandSuspend}]"/>
<org.eventb.core.guard name="_OudVA9LLEeOIk6vzYQGQiQ" org.eventb.core.label="grd401" org.eventb.core.predicate="staperprocs = procs ∩ period_of_process∼[{INFINITE_TIME_VALUE}] ∩ process_wait_type∼[{PROC_WAIT_PARTITIONNORMAL}]"/>
<org.eventb.core.guard name="_OudVBNLLEeOIk6vzYQGQiQ" org.eventb.core.label="grd402" org.eventb.core.predicate="dstaperprocs = procs ∩ period_of_process∼[{INFINITE_TIME_VALUE}] ∩ process_wait_type∼[{PROC_WAIT_DELAY}]"/>
<org.eventb.core.guard name="_Oud8ENLLEeOIk6vzYQGQiQ" org.eventb.core.label="grd403" org.eventb.core.predicate="suspaperprocs = procs2"/>
<org.eventb.core.guard name="_Oud8EdLLEeOIk6vzYQGQiQ" org.eventb.core.label="grd404" org.eventb.core.predicate="stperprocs = (procs ∖ period_of_process∼[{INFINITE_TIME_VALUE}]) ∩ process_wait_type∼[{PROC_WAIT_PARTITIONNORMAL}]"/>
<org.eventb.core.guard name="_Oud8EtLLEeOIk6vzYQGQiQ" org.eventb.core.label="grd405" org.eventb.core.predicate="dstperprocs =  (procs ∖ period_of_process∼[{INFINITE_TIME_VALUE}]) ∩ process_wait_type∼[{PROC_WAIT_DELAY}]"/>
<org.eventb.core.guard name="_xDgdINLMEeOIk6vzYQGQiQ" org.eventb.core.label="grd406" org.eventb.core.predicate="rlt ∈ dstaperprocs → ℕ"/>
<org.eventb.core.guard name="_xDhEMNLMEeOIk6vzYQGQiQ" org.eventb.core.label="grd407" org.eventb.core.predicate="∀p·(p∈dstaperprocs ⇒ rlt(p) = clock_tick∗ONE_TICK_TIME + delaytime_of_process(p))"/>
<org.eventb.core.guard name="_9zAqENLWEeOIk6vzYQGQiQ" org.eventb.core.label="grd408" org.eventb.core.predicate="nrlt1 ∈ stperprocs → ℕ"/>
<org.eventb.core.guard name="_9zAqEdLWEeOIk6vzYQGQiQ" org.eventb.core.label="grd409" org.eventb.core.predicate="∀p,x,y,b·(p∈stperprocs ∧ ((x↦y)↦b)= firstperiodicprocstart_timeWindow_of_Partition(part)⇒ nrlt1(p) = ((clock_tick∗ONE_TICK_TIME)÷majorFrame+1)∗majorFrame + x)"/>
<org.eventb.core.guard name="_LS0gsNMwEeOzJJnArOuL7g" org.eventb.core.label="grd410" org.eventb.core.predicate="nrlt2 ∈ dstperprocs → ℕ"/>
<org.eventb.core.guard name="_nhuJ8NMxEeOzJJnArOuL7g" org.eventb.core.label="grd411" org.eventb.core.predicate="∀p,x,y,b·(p∈dstperprocs ∧ ((x↦y)↦b)= firstperiodicprocstart_timeWindow_of_Partition(part) ⇒ nrlt2(p) = ((clock_tick∗ONE_TICK_TIME)÷majorFrame+1)∗majorFrame + x +delaytime_of_process(p) )"/>
<org.eventb.core.guard name="_xX2-4dfiEeOuSP1sPLS_Hw" org.eventb.core.label="grd412" org.eventb.core.predicate="newm = PM_NORMAL"/>
<org.eventb.core.guard name="_aWsB0NltEeO0qb61sEhIIg" org.eventb.core.label="grd413" org.eventb.core.predicate="dl1∈staperprocs ∪suspaperprocs → ℕ"/>
<org.eventb.core.guard name="_aWsB0dltEeO0qb61sEhIIg" org.eventb.core.label="grd414" org.eventb.core.predicate="∀p·(p∈staperprocs ∪suspaperprocs ⇒ dl1(p)=clock_tick∗ONE_TICK_TIME + timecapacity_of_process(p))"/>
<org.eventb.core.guard name="_aWsB0tltEeO0qb61sEhIIg" org.eventb.core.label="grd415" org.eventb.core.predicate="dl2 ∈dstaperprocs → ℕ"/>
<org.eventb.core.guard name="_aWsB09ltEeO0qb61sEhIIg" org.eventb.core.label="grd416" org.eventb.core.predicate="∀p·(p∈dstaperprocs ⇒ dl2(p)=clock_tick∗ONE_TICK_TIME +delaytime_of_process(p)+ timecapacity_of_process(p))"/>
<org.eventb.core.guard name="_aWsB1NltEeO0qb61sEhIIg" org.eventb.core.label="grd417" org.eventb.core.predicate="dl3∈stperprocs → ℕ"/>
<org.eventb.core.guard name="_aWsB1dltEeO0qb61sEhIIg" org.eventb.core.label="grd418" org.eventb.core.predicate="∀p·(p∈stperprocs ⇒ dl3(p)=clock_tick∗ONE_TICK_TIME +timecapacity_of_process(p))"/>
<org.eventb.core.guard name="_aWsB1tltEeO0qb61sEhIIg" org.eventb.core.label="grd419" org.eventb.core.predicate="dl4∈dstperprocs → ℕ"/>
<org.eventb.core.guard name="_aWsB19ltEeO0qb61sEhIIg" org.eventb.core.label="grd420" org.eventb.core.predicate="∀p·(p∈dstperprocs ⇒ dl4(p)=clock_tick∗ONE_TICK_TIME +delaytime_of_process(p) + timecapacity_of_process(p))"/>
<org.eventb.core.witness name="_uqhHAeLnEeOCZ4h25r3zSQ" org.eventb.core.label="procsstate" org.eventb.core.predicate="procsstate = (staperprocs ×{PS_Ready}) ∪ ((dstaperprocs ∪ stperprocs ∪ dstperprocs)×{PS_Waiting})"/>
<org.eventb.core.action name="_raqI0NLNEeOIk6vzYQGQiQ" org.eventb.core.assignment="partition_mode(part) ≔ newm" org.eventb.core.label="act400"/>
<org.eventb.core.action name="_xDhEMdLMEeOIk6vzYQGQiQ" org.eventb.core.assignment="process_state ≔  (process_state (staperprocs ×{PS_Ready}))  (suspaperprocs × {PS_Suspend})" org.eventb.core.label="act401"/>
<org.eventb.core.action name="_xDhEMtLMEeOIk6vzYQGQiQ" org.eventb.core.assignment="releasepoint_of_process ≔  releasepoint_of_process  rlt nrlt1  nrlt2" org.eventb.core.comment="@act403 nextreleasepoint_of_process ≔  nextreleasepoint_of_process nrlt1  nrlt2" org.eventb.core.label="act402"/>
<org.eventb.core.action name="_aWsB2NltEeO0qb61sEhIIg" org.eventb.core.assignment="deadlinetime_of_process ≔  deadlinetime_of_process  dl1  dl2  dl3  dl4" org.eventb.core.label="act403"/>
<org.eventb.core.action name="_8VZ0QNMxEeOzJJnArOuL7g" org.eventb.core.assignment="locklevel_of_partition(part) ≔ 0" org.eventb.core.comment="@act405 schedulable_of_partition(part) ≔ TRUE" org.eventb.core.label="act404"/>
</org.eventb.core.event>
<org.eventb.core.event name="_QyQkMtHYEeOO1v6vzqtXww" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="set_partition_mode_to_coldstart">
<org.eventb.core.refinesEvent name="_xZMl8DVIEeSxw-wt7-_VGQ" org.eventb.core.target="set_partition_mode_to_coldstart"/>
<org.eventb.core.guard name="_uqd5oNfkEeOuSP1sPLS_Hw" org.eventb.core.label="grd40" org.eventb.core.predicate="current_partition_flag = TRUE ∧ current_partition=part"/>
<org.eventb.core.action name="_neo7oNJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="process_wait_type ≔ procs ⩤ process_wait_type" org.eventb.core.label="act401"/>
<org.eventb.core.action name="_neo7odJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="locklevel_of_partition(part) ≔ 1" org.eventb.core.comment="@act403 preemption_of_partitions(part) ≔ TRUE&#10;         @act404 startcondition_of_partition(part) ≔   NORMAL_START&#10;         @act404 schedulable_of_partition(part) ≔ FALSE " org.eventb.core.label="act402"/>
<org.eventb.core.action name="_nepisdJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="basepriority_of_process ≔  procs ⩤ basepriority_of_process" org.eventb.core.label="act405"/>
<org.eventb.core.action name="_nepistJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="period_of_process ≔   procs ⩤ period_of_process" org.eventb.core.label="act406"/>
<org.eventb.core.action name="_nepis9J_EeOIk6vzYQGQiQ" org.eventb.core.assignment="timecapacity_of_process ≔   procs ⩤ timecapacity_of_process" org.eventb.core.label="act407"/>
<org.eventb.core.action name="_nepitNJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="deadline_of_process ≔   procs ⩤ deadline_of_process" org.eventb.core.label="act408"/>
<org.eventb.core.action name="_neqJwNJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="currentpriority_of_process ≔   procs ⩤ currentpriority_of_process" org.eventb.core.label="act409"/>
<org.eventb.core.action name="_neqJwdJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="deadlinetime_of_process ≔   procs ⩤ deadlinetime_of_process" org.eventb.core.label="act410"/>
<org.eventb.core.action name="_neqJwtJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="releasepoint_of_process ≔   procs ⩤ releasepoint_of_process" org.eventb.core.comment="@act412 nextreleasepoint_of_process ≔   procs ⩤ nextreleasepoint_of_process" org.eventb.core.label="act411"/>
<org.eventb.core.action name="_aZyzANKEEeOIk6vzYQGQiQ" org.eventb.core.assignment="delaytime_of_process ≔ procs ⩤ delaytime_of_process" org.eventb.core.label="act413"/>
<org.eventb.core.action name="_F8VcQNLEEeOIk6vzYQGQiQ" org.eventb.core.assignment="timeout_trigger ≔  procs ⩤ timeout_trigger" org.eventb.core.label="act414"/>
<org.eventb.core.action name="_F8WDUNLEEeOIk6vzYQGQiQ" org.eventb.core.assignment="errorhandler_of_partition ≔  {part} ⩤ errorhandler_of_partition" org.eventb.core.label="act415"/>
<org.eventb.core.action name="_F8WDUdLEEeOIk6vzYQGQiQ" org.eventb.core.assignment="process_call_errorhandler ≔  procs ⩤ process_call_errorhandler" org.eventb.core.comment="@act417 current_partition_flag ≔ FALSE" org.eventb.core.label="act416"/>
<org.eventb.core.action name="_nKngINckEeOuG80hxTAROw" org.eventb.core.assignment="current_process_flag ≔ FALSE" org.eventb.core.label="act418"/>
<org.eventb.core.action name="_RzG2INfLEeOie6XboyvqsA" org.eventb.core.assignment="preempter_of_partition ≔  {part} ⩤ preempter_of_partition" org.eventb.core.label="act419"/>
</org.eventb.core.event>
<org.eventb.core.event name="_QyRLQdHYEeOO1v6vzqtXww" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="set_partition_mode_to_warmstart">
<org.eventb.core.refinesEvent name="_xZWW8DVIEeSxw-wt7-_VGQ" org.eventb.core.target="set_partition_mode_to_warmstart"/>
<org.eventb.core.guard name="_uqd5odfkEeOuSP1sPLS_Hw" org.eventb.core.label="grd40" org.eventb.core.predicate="current_partition_flag = TRUE ∧ current_partition=part"/>
<org.eventb.core.action name="_neqw0NJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="process_wait_type ≔ procs ⩤ process_wait_type" org.eventb.core.label="act401"/>
<org.eventb.core.action name="_neqw0dJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="locklevel_of_partition(part) ≔ 1" org.eventb.core.comment="@act403 preemption_of_partitions(part) ≔ TRUE&#10;         @act404 startcondition_of_partition(part) ≔   NORMAL_START&#10;         @act404 schedulable_of_partition(part) ≔ FALSE " org.eventb.core.label="act402"/>
<org.eventb.core.action name="_nerX4NJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="basepriority_of_process ≔  procs ⩤ basepriority_of_process" org.eventb.core.label="act405"/>
<org.eventb.core.action name="_nerX4dJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="period_of_process ≔   procs ⩤ period_of_process" org.eventb.core.label="act406"/>
<org.eventb.core.action name="_nerX4tJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="timecapacity_of_process ≔   procs ⩤ timecapacity_of_process" org.eventb.core.label="act407"/>
<org.eventb.core.action name="_nerX49J_EeOIk6vzYQGQiQ" org.eventb.core.assignment="deadline_of_process ≔   procs ⩤ deadline_of_process" org.eventb.core.label="act408"/>
<org.eventb.core.action name="_ner-8NJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="currentpriority_of_process ≔   procs ⩤ currentpriority_of_process" org.eventb.core.label="act409"/>
<org.eventb.core.action name="_ner-8dJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="deadlinetime_of_process ≔   procs ⩤ deadlinetime_of_process" org.eventb.core.label="act410"/>
<org.eventb.core.action name="_ner-8tJ_EeOIk6vzYQGQiQ" org.eventb.core.assignment="releasepoint_of_process ≔   procs ⩤ releasepoint_of_process" org.eventb.core.comment="@act412 nextreleasepoint_of_process ≔   procs ⩤ nextreleasepoint_of_process" org.eventb.core.label="act411"/>
<org.eventb.core.action name="_aZ0oMNKEEeOIk6vzYQGQiQ" org.eventb.core.assignment="delaytime_of_process ≔ procs ⩤ delaytime_of_process" org.eventb.core.label="act413"/>
<org.eventb.core.action name="_F8X4gNLEEeOIk6vzYQGQiQ" org.eventb.core.assignment="timeout_trigger ≔  procs ⩤ timeout_trigger" org.eventb.core.label="act414"/>
<org.eventb.core.action name="_F8X4gdLEEeOIk6vzYQGQiQ" org.eventb.core.assignment="errorhandler_of_partition ≔  {part} ⩤ errorhandler_of_partition" org.eventb.core.label="act415"/>
<org.eventb.core.action name="_F8YfkNLEEeOIk6vzYQGQiQ" org.eventb.core.assignment="process_call_errorhandler ≔  procs ⩤ process_call_errorhandler" org.eventb.core.comment="@act417 current_partition_flag ≔ FALSE" org.eventb.core.label="act416"/>
<org.eventb.core.action name="_nKngItckEeOuG80hxTAROw" org.eventb.core.assignment="current_process_flag ≔ FALSE" org.eventb.core.label="act418"/>
<org.eventb.core.action name="_RzG2ItfLEeOie6XboyvqsA" org.eventb.core.assignment="preempter_of_partition ≔  {part} ⩤ preempter_of_partition" org.eventb.core.label="act419"/>
</org.eventb.core.event>
<org.eventb.core.event name="_k_pDgNHYEeOO1v6vzqtXww" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="get_process_id">
<org.eventb.core.parameter name="_kvXgoNM9EeOzJJnArOuL7g" org.eventb.core.identifier="proc"/>
<org.eventb.core.guard name="_kvXgodM9EeOzJJnArOuL7g" org.eventb.core.label="grd01" org.eventb.core.predicate="current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_kvXgotM9EeOzJJnArOuL7g" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_qmsgYNM9EeOzJJnArOuL7g" org.eventb.core.label="grd03" org.eventb.core.predicate="processes_of_partition(proc) = current_partition"/>
</org.eventb.core.event>
<org.eventb.core.event name="_k_pDgdHYEeOO1v6vzqtXww" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="get_process_status">
<org.eventb.core.parameter name="_xrlfcNM9EeOzJJnArOuL7g" org.eventb.core.identifier="proc"/>
<org.eventb.core.guard name="_xrlfcdM9EeOzJJnArOuL7g" org.eventb.core.label="grd01" org.eventb.core.predicate="current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_xrlfctM9EeOzJJnArOuL7g" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_xrlfc9M9EeOzJJnArOuL7g" org.eventb.core.label="grd03" org.eventb.core.predicate="processes_of_partition(proc) = current_partition"/>
</org.eventb.core.event>
<org.eventb.core.event name="_jg6cks5zEeOj2-yVf9avbQ" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="create_process">
<org.eventb.core.refinesEvent name="_jg6ck85zEeOj2-yVf9avbQ" org.eventb.core.target="create_process"/>
<org.eventb.core.parameter name="_aGcSwNNAEeOzJJnArOuL7g" org.eventb.core.identifier="basepriority"/>
<org.eventb.core.parameter name="_aGcSwdNAEeOzJJnArOuL7g" org.eventb.core.identifier="period"/>
<org.eventb.core.parameter name="_aGcSwtNAEeOzJJnArOuL7g" org.eventb.core.identifier="timecapacity"/>
<org.eventb.core.parameter name="_d8BHENNJEeOzJJnArOuL7g" org.eventb.core.identifier="dl"/>
<org.eventb.core.guard name="_Q6BWwNNREeOzJJnArOuL7g" org.eventb.core.label="grd201" org.eventb.core.predicate="current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_qXVR4NNBEeOzJJnArOuL7g" org.eventb.core.label="grd200" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_aGcSw9NAEeOzJJnArOuL7g" org.eventb.core.label="grd20" org.eventb.core.predicate="basepriority ∈ MIN_PRIORITY_VALUE ‥ MAX_PRIORITY_VALUE"/>
<org.eventb.core.guard name="_aGcSxNNAEeOzJJnArOuL7g" org.eventb.core.label="grd21" org.eventb.core.predicate="period ∈ ℤ"/>
<org.eventb.core.guard name="_aGcSxdNAEeOzJJnArOuL7g" org.eventb.core.label="grd22" org.eventb.core.predicate="timecapacity ∈ ℤ"/>
<org.eventb.core.guard name="_qXVR4dNBEeOzJJnArOuL7g" org.eventb.core.label="grd23" org.eventb.core.predicate="period≠ INFINITE_TIME_VALUE ⇒ (∃n·(n∈ℕ ∧period =n∗Period_of_Partition(part)))"/>
<org.eventb.core.guard name="_qXVR4tNBEeOzJJnArOuL7g" org.eventb.core.label="grd24" org.eventb.core.predicate="period≠ INFINITE_TIME_VALUE ⇒ (timecapacity ≤ period)"/>
<org.eventb.core.guard name="_d8BHEdNJEeOzJJnArOuL7g" org.eventb.core.label="grd25" org.eventb.core.predicate="dl ∈DEADLINE_TYPE"/>
<org.eventb.core.guard name="_N9T2oNUVEeOE_q1ibjWlpA" org.eventb.core.label="ptype1" org.eventb.core.predicate="(ptype=APERIOD_PROC⇔ period=INFINITE_TIME_VALUE)"/>
<org.eventb.core.guard name="_N9T2odUVEeOE_q1ibjWlpA" org.eventb.core.label="ptype2" org.eventb.core.predicate="(ptype=PERIOD_PROC⇔ period≠INFINITE_TIME_VALUE)"/>
<org.eventb.core.action name="_aGcSxtNAEeOzJJnArOuL7g" org.eventb.core.assignment="basepriority_of_process(proc) ≔ basepriority" org.eventb.core.label="act21"/>
<org.eventb.core.action name="_aGcSx9NAEeOzJJnArOuL7g" org.eventb.core.assignment="period_of_process(proc) ≔  period" org.eventb.core.label="act22"/>
<org.eventb.core.action name="_aGcSyNNAEeOzJJnArOuL7g" org.eventb.core.assignment="timecapacity_of_process(proc) ≔  timecapacity" org.eventb.core.label="act23"/>
<org.eventb.core.action name="_d8BHEtNJEeOzJJnArOuL7g" org.eventb.core.assignment="deadline_of_process(proc) ≔  dl" org.eventb.core.label="act34"/>
<org.eventb.core.action name="_idUvUOFQEeOlhdB8eyQyLQ" org.eventb.core.assignment="currentpriority_of_process(proc) ≔  basepriority" org.eventb.core.comment="@act36 process_ids ≔ process_ids ∪ {proc}" org.eventb.core.label="act35"/>
</org.eventb.core.event>
<org.eventb.core.event name="_sjczMNHYEeOO1v6vzqtXww" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="set_priority">
<org.eventb.core.parameter name="_IQKvkNNSEeOzJJnArOuL7g" org.eventb.core.identifier="p"/>
<org.eventb.core.parameter name="_IQKvkdNSEeOzJJnArOuL7g" org.eventb.core.identifier="pri"/>
<org.eventb.core.guard name="_IQKvktNSEeOzJJnArOuL7g" org.eventb.core.label="grd10" org.eventb.core.predicate="current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_IQKvk9NSEeOzJJnArOuL7g" org.eventb.core.label="grd11" org.eventb.core.predicate="p ∈processes"/>
<org.eventb.core.guard name="_IQKvlNNSEeOzJJnArOuL7g" org.eventb.core.label="grd12" org.eventb.core.predicate="p ∈ processes_of_partition∼[{current_partition}]"/>
<org.eventb.core.guard name="_IQKvltNSEeOzJJnArOuL7g" org.eventb.core.label="grd14" org.eventb.core.predicate="pri ∈ MIN_PRIORITY_VALUE ‥ MAX_PRIORITY_VALUE"/>
<org.eventb.core.guard name="_IQKvl9NSEeOzJJnArOuL7g" org.eventb.core.comment="@grd16 p∉ran(errorhandler_of_partition)" org.eventb.core.label="grd15" org.eventb.core.predicate="process_state(p) ≠ PS_Dormant"/>
<org.eventb.core.action name="_IQKvmNNSEeOzJJnArOuL7g" org.eventb.core.assignment="currentpriority_of_process(p) ≔ pri" org.eventb.core.comment="@act11 need_reschedule :∣ (locklevel_of_partition(current_partition) =0 ∧(process_state(p)=PS_Ready ∨ process_state(p)=PS_Running)⇒ need_reschedule' = TRUE) ∧ (locklevel_of_partition(current_partition) ≠0 ⇒ need_reschedule' = need_reschedule)" org.eventb.core.label="act10"/>
<org.eventb.core.action name="_IQKvmdNSEeOzJJnArOuL7g" org.eventb.core.assignment="need_reschedule :∣ (locklevel_of_partition(current_partition) =0 ⇒ need_reschedule' = TRUE) ∧ (locklevel_of_partition(current_partition) ≠0 ⇒ need_reschedule' = need_reschedule)" org.eventb.core.label="act11"/>
</org.eventb.core.event>
<org.eventb.core.event name="_QyRLQ9HYEeOO1v6vzqtXww" org.eventb.core.comment="extends suspend_self&#10;any timeout timeouttrig waittype" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="suspend_self">
<org.eventb.core.refinesEvent name="_QyRyUNHYEeOO1v6vzqtXww" org.eventb.core.target="suspend_self"/>
<org.eventb.core.parameter name="_kXuygNl5EeO0qb61sEhIIg" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_kXuygdl5EeO0qb61sEhIIg" org.eventb.core.identifier="proc"/>
<org.eventb.core.parameter name="_kXuygtl5EeO0qb61sEhIIg" org.eventb.core.identifier="newstate"/>
<org.eventb.core.parameter name="_bJxdYNNTEeOzJJnArOuL7g" org.eventb.core.identifier="timeout"/>
<org.eventb.core.parameter name="_6l6esNNUEeOzJJnArOuL7g" org.eventb.core.identifier="timeouttrig"/>
<org.eventb.core.parameter name="_h8axsNNaEeOzJJnArOuL7g" org.eventb.core.identifier="waittype"/>
<org.eventb.core.guard name="_kXuyg9l5EeO0qb61sEhIIg" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS"/>
<org.eventb.core.guard name="_kXuyhNl5EeO0qb61sEhIIg" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_kXuyhdl5EeO0qb61sEhIIg" org.eventb.core.label="grd03" org.eventb.core.predicate="newstate ∈ PROCESS_STATES"/>
<org.eventb.core.guard name="_kXuyhtl5EeO0qb61sEhIIg" org.eventb.core.label="grd06" org.eventb.core.predicate="processes_of_partition(proc) = part"/>
<org.eventb.core.guard name="_kXuyh9l5EeO0qb61sEhIIg" org.eventb.core.label="grd31" org.eventb.core.predicate="partition_mode(part) = PM_NORMAL"/>
<org.eventb.core.guard name="_kXuyiNl5EeO0qb61sEhIIg" org.eventb.core.label="grd32" org.eventb.core.predicate="process_state(proc) = PS_Running"/>
<org.eventb.core.guard name="_kXuyidl5EeO0qb61sEhIIg" org.eventb.core.label="grd33" org.eventb.core.predicate="newstate = PS_Suspend"/>
<org.eventb.core.guard name="_vcX2EPzjEeOYCOxQsSw6Qg" org.eventb.core.label="grd34" org.eventb.core.predicate="periodtype_of_process(proc) = APERIOD_PROC"/>
<org.eventb.core.guard name="_bJxdYdNTEeOzJJnArOuL7g" org.eventb.core.label="grd401" org.eventb.core.predicate="timeout∈ℤ ∧ timeout≠0"/>
<org.eventb.core.guard name="_KrXUwNNUEeOzJJnArOuL7g" org.eventb.core.label="grd402" org.eventb.core.predicate="current_process_flag = TRUE ∧ current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_7sGKAdNcEeOzJJnArOuL7g" org.eventb.core.label="grd200" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_KrXUwdNUEeOzJJnArOuL7g" org.eventb.core.label="grd403" org.eventb.core.predicate="proc = current_process"/>
<org.eventb.core.guard name="_KrXUwtNUEeOzJJnArOuL7g" org.eventb.core.label="grd404" org.eventb.core.predicate="part∈dom(errorhandler_of_partition) ⇒ proc ≠ errorhandler_of_partition(part)"/>
<org.eventb.core.guard name="_KrXUw9NUEeOzJJnArOuL7g" org.eventb.core.label="grd405" org.eventb.core.predicate="locklevel_of_partition(part) = 0"/>
<org.eventb.core.guard name="_Wr6VgNNUEeOzJJnArOuL7g" org.eventb.core.label="grd406" org.eventb.core.predicate="period_of_process(proc) ≠ INFINITE_TIME_VALUE"/>
<org.eventb.core.guard name="_6l6esdNUEeOzJJnArOuL7g" org.eventb.core.label="grd407" org.eventb.core.predicate="timeouttrig ∈ processes ⇸ (PROCESS_STATES × ℕ1)"/>
<org.eventb.core.guard name="_6l6estNUEeOzJJnArOuL7g" org.eventb.core.label="grd408" org.eventb.core.predicate="timeout ≠ INFINITE_TIME_VALUE ∧ timeout≠0⇒ timeouttrig = {proc ↦ (PS_Ready ↦ (timeout +clock_tick ∗ ONE_TICK_TIME))}"/>
<org.eventb.core.guard name="_6l6es9NUEeOzJJnArOuL7g" org.eventb.core.label="grd409" org.eventb.core.predicate="timeout = INFINITE_TIME_VALUE ⇒  timeouttrig = ∅"/>
<org.eventb.core.guard name="_h8axsdNaEeOzJJnArOuL7g" org.eventb.core.label="grd410" org.eventb.core.predicate="waittype∈processes⇸PROCESS_WAIT_TYPES"/>
<org.eventb.core.guard name="_h8axstNaEeOzJJnArOuL7g" org.eventb.core.label="grd411" org.eventb.core.predicate="timeout&gt;0 ⇒ waittype={proc ↦ PROC_WAIT_TIMEOUT}"/>
<org.eventb.core.guard name="_h8axs9NaEeOzJJnArOuL7g" org.eventb.core.label="grd412" org.eventb.core.predicate="(timeout =  INFINITE_TIME_VALUE ∨ timeout = 0) ⇒ waittype = ∅"/>
<org.eventb.core.action name="_kX38cNl5EeO0qb61sEhIIg" org.eventb.core.assignment="process_state(proc) ≔ newstate" org.eventb.core.label="act11"/>
<org.eventb.core.action name="_6l6etNNUEeOzJJnArOuL7g" org.eventb.core.assignment="current_process_flag :∣(timeout=0⇒current_process_flag' = TRUE) ∧ (timeout&gt;0⇒current_process_flag' = FALSE)" org.eventb.core.label="act40"/>
<org.eventb.core.action name="_6l6etdNUEeOzJJnArOuL7g" org.eventb.core.assignment="timeout_trigger ≔ timeout_trigger  timeouttrig" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_6l6ettNUEeOzJJnArOuL7g" org.eventb.core.assignment="need_reschedule :∣(timeout=0⇒need_reschedule' = FALSE) ∧ (timeout&gt;0⇒need_reschedule' = TRUE)" org.eventb.core.label="act42"/>
<org.eventb.core.action name="_h8axtNNaEeOzJJnArOuL7g" org.eventb.core.assignment="process_wait_type ≔  process_wait_type  waittype" org.eventb.core.label="act43"/>
</org.eventb.core.event>
<org.eventb.core.event name="_QyRyUdHYEeOO1v6vzqtXww" org.eventb.core.comment="extends suspend" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="suspend">
<org.eventb.core.refinesEvent name="_QyRyUtHYEeOO1v6vzqtXww" org.eventb.core.target="suspend"/>
<org.eventb.core.parameter name="_kX38cdl5EeO0qb61sEhIIg" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_kX38ctl5EeO0qb61sEhIIg" org.eventb.core.identifier="proc"/>
<org.eventb.core.parameter name="_kX38c9l5EeO0qb61sEhIIg" org.eventb.core.identifier="newstate"/>
<org.eventb.core.guard name="_kX38dNl5EeO0qb61sEhIIg" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS"/>
<org.eventb.core.guard name="_kX38ddl5EeO0qb61sEhIIg" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_kX38dtl5EeO0qb61sEhIIg" org.eventb.core.label="grd03" org.eventb.core.predicate="newstate ∈ PROCESS_STATES"/>
<org.eventb.core.guard name="_kX38d9l5EeO0qb61sEhIIg" org.eventb.core.label="grd06" org.eventb.core.predicate="processes_of_partition(proc) = part"/>
<org.eventb.core.guard name="_ev9U4Nl9EeO0qb61sEhIIg" org.eventb.core.label="grd30" org.eventb.core.predicate="partition_mode(part) = PM_NORMAL ∨ partition_mode(part) = PM_COLD_START ∨ partition_mode(part) = PM_WARM_START"/>
<org.eventb.core.guard name="_U58ugNl8EeO0qb61sEhIIg" org.eventb.core.label="grd31" org.eventb.core.predicate="partition_mode(part) = PM_NORMAL ⇒  (process_state(proc) = PS_Ready ∧ newstate = PS_Suspend)∨  (process_state(proc) = PS_Waiting ∧ newstate = PS_WaitandSuspend)"/>
<org.eventb.core.guard name="_ev9U4dl9EeO0qb61sEhIIg" org.eventb.core.label="grd32" org.eventb.core.predicate="(partition_mode(part) = PM_COLD_START ∨  partition_mode(part) = PM_WARM_START)⇒  (process_state(proc) = PS_Waiting ∧ newstate = PS_WaitandSuspend)"/>
<org.eventb.core.guard name="_Q6iFYNNXEeOzJJnArOuL7g" org.eventb.core.label="grd40" org.eventb.core.predicate="current_process_flag = TRUE ∧ current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_7sGKAtNcEeOzJJnArOuL7g" org.eventb.core.label="grd200" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_Q6YUYdNXEeOzJJnArOuL7g" org.eventb.core.label="grd41" org.eventb.core.predicate="current_process_flag = TRUE ⇒ proc ≠ current_process"/>
<org.eventb.core.guard name="_Q6YUYNNXEeOzJJnArOuL7g" org.eventb.core.comment="preemption is enabled or the PROCESS_ID is not the process which the error handler has pre-empted" org.eventb.core.label="grd42" org.eventb.core.predicate="locklevel_of_partition(part) = 0 ∨ proc ∉ ran(process_call_errorhandler)"/>
<org.eventb.core.guard name="_Q6iFYdNXEeOzJJnArOuL7g" org.eventb.core.comment="periodic process could not be suspend" org.eventb.core.label="grd43" org.eventb.core.predicate="period_of_process(proc) = INFINITE_TIME_VALUE"/>
<org.eventb.core.guard name="_ZGzjQNNXEeOzJJnArOuL7g" org.eventb.core.label="grd45" org.eventb.core.predicate="process_state(proc) ≠ PS_Dormant"/>
<org.eventb.core.guard name="_W7VUwNNYEeOzJJnArOuL7g" org.eventb.core.label="grd46" org.eventb.core.predicate="process_state(proc) ≠PS_Suspend ∧  process_state(proc) ≠PS_WaitandSuspend"/>
<org.eventb.core.action name="_kX38eNl5EeO0qb61sEhIIg" org.eventb.core.assignment="process_state(proc) ≔ newstate" org.eventb.core.label="act11"/>
</org.eventb.core.event>
<org.eventb.core.event name="_QyRyU9HYEeOO1v6vzqtXww" org.eventb.core.comment="extends resume" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="resume">
<org.eventb.core.refinesEvent name="_QySZYNHYEeOO1v6vzqtXww" org.eventb.core.target="resume"/>
<org.eventb.core.parameter name="_kX38edl5EeO0qb61sEhIIg" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_kX38etl5EeO0qb61sEhIIg" org.eventb.core.identifier="proc"/>
<org.eventb.core.parameter name="_kX38e9l5EeO0qb61sEhIIg" org.eventb.core.identifier="newstate"/>
<org.eventb.core.parameter name="_7sGKA9NcEeOzJJnArOuL7g" org.eventb.core.identifier="reschedule"/>
<org.eventb.core.guard name="_kX38fNl5EeO0qb61sEhIIg" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS"/>
<org.eventb.core.guard name="_kX38fdl5EeO0qb61sEhIIg" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_kX38ftl5EeO0qb61sEhIIg" org.eventb.core.label="grd03" org.eventb.core.predicate="newstate ∈ PROCESS_STATES"/>
<org.eventb.core.guard name="_kX38f9l5EeO0qb61sEhIIg" org.eventb.core.label="grd06" org.eventb.core.predicate="processes_of_partition(proc) = part"/>
<org.eventb.core.guard name="_U58ugdl8EeO0qb61sEhIIg" org.eventb.core.label="grd31" org.eventb.core.predicate="partition_mode(part) = PM_NORMAL ∨ partition_mode(part) = PM_COLD_START ∨ partition_mode(part) = PM_WARM_START"/>
<org.eventb.core.guard name="_z80moNNbEeOzJJnArOuL7g" org.eventb.core.label="grd40" org.eventb.core.predicate="current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_7sGKBNNcEeOzJJnArOuL7g" org.eventb.core.label="grd200" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_z80modNbEeOzJJnArOuL7g" org.eventb.core.label="grd41" org.eventb.core.predicate="current_process_flag = TRUE ⇒ proc ≠ current_process"/>
<org.eventb.core.guard name="_z80motNbEeOzJJnArOuL7g" org.eventb.core.label="grd42" org.eventb.core.predicate="process_state(proc) ≠ PS_Dormant"/>
<org.eventb.core.guard name="_z80mo9NbEeOzJJnArOuL7g" org.eventb.core.label="grd43" org.eventb.core.predicate="period_of_process(proc) = INFINITE_TIME_VALUE"/>
<org.eventb.core.guard name="_z80mpNNbEeOzJJnArOuL7g" org.eventb.core.label="grd44" org.eventb.core.predicate="process_state(proc) =PS_Suspend ∨  process_state(proc) = PS_WaitandSuspend"/>
<org.eventb.core.guard name="_7sGKBdNcEeOzJJnArOuL7g" org.eventb.core.label="grd45" org.eventb.core.predicate="reschedule ∈ BOOL"/>
<org.eventb.core.guard name="_7sGKBtNcEeOzJJnArOuL7g" org.eventb.core.comment="@grd47 process_state(proc) =PS_Suspend ∨ (process_state(proc) =PS_WaitandSuspend ∧ process_wait_type(proc)≠PROC_WAIT_TIMEOUT ∧ process_wait_type(proc)≠PROC_WAIT_OBJ) ⇒ newstate = PS_Ready&#10;@grd48 process_state(proc) =PS_WaitandSuspend ∧ process_wait_type(proc)=PROC_WAIT_TIMEOUT ∧ process_wait_type(proc)=PROC_WAIT_OBJ ⇒ newstate = PS_Waiting&#10;these two lines are from RESUME operation of ARINC653, the next two lines are correct" org.eventb.core.label="grd46" org.eventb.core.predicate="(process_state(proc) = PS_Suspend ⇒ reschedule = TRUE) ∧ (process_state(proc) = PS_WaitandSuspend ⇒ reschedule = FALSE)"/>
<org.eventb.core.guard name="_7sGKB9NcEeOzJJnArOuL7g" org.eventb.core.label="grd47" org.eventb.core.predicate="process_state(proc) =PS_Suspend ⇒ newstate = PS_Ready"/>
<org.eventb.core.guard name="_7sPT8NNcEeOzJJnArOuL7g" org.eventb.core.label="grd48" org.eventb.core.predicate="process_state(proc) =PS_WaitandSuspend ⇒ newstate = PS_Waiting"/>
<org.eventb.core.action name="_kX38gNl5EeO0qb61sEhIIg" org.eventb.core.assignment="process_state(proc) ≔ newstate" org.eventb.core.label="act11"/>
<org.eventb.core.action name="_7sPT8dNcEeOzJJnArOuL7g" org.eventb.core.assignment="timeout_trigger :∣  (newstate = PS_Ready ⇒ timeout_trigger'=  {proc}⩤ timeout_trigger) ∧ (newstate ≠ PS_Ready ⇒ timeout_trigger'=timeout_trigger)" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_7sPT8tNcEeOzJJnArOuL7g" org.eventb.core.assignment="need_reschedule :∣ (locklevel_of_partition(current_partition) =0 ∧  reschedule = TRUE ⇒ need_reschedule' = TRUE)&#10;             ∧ (locklevel_of_partition(current_partition) &gt; 0 ∨  reschedule = FALSE ⇒ need_reschedule' = need_reschedule)" org.eventb.core.label="act42"/>
</org.eventb.core.event>
<org.eventb.core.event name="_QySZYdHYEeOO1v6vzqtXww" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="stop_self">
<org.eventb.core.refinesEvent name="_QySZYtHYEeOO1v6vzqtXww" org.eventb.core.target="stop_self"/>
<org.eventb.core.parameter name="_kX38gdl5EeO0qb61sEhIIg" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_kX38gtl5EeO0qb61sEhIIg" org.eventb.core.identifier="proc"/>
<org.eventb.core.parameter name="_kX38g9l5EeO0qb61sEhIIg" org.eventb.core.identifier="newstate"/>
<org.eventb.core.parameter name="_Ci1tcNNfEeOzJJnArOuL7g" org.eventb.core.identifier="newlocklevel"/>
<org.eventb.core.parameter name="_Ci1tcdNfEeOzJJnArOuL7g" org.eventb.core.identifier="newproc"/>
<org.eventb.core.parameter name="_Ci1tctNfEeOzJJnArOuL7g" org.eventb.core.identifier="resch"/>
<org.eventb.core.guard name="_kYBtcNl5EeO0qb61sEhIIg" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS"/>
<org.eventb.core.guard name="_kYBtcdl5EeO0qb61sEhIIg" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_kYBtctl5EeO0qb61sEhIIg" org.eventb.core.label="grd03" org.eventb.core.predicate="newstate ∈ PROCESS_STATES"/>
<org.eventb.core.guard name="_kYBtc9l5EeO0qb61sEhIIg" org.eventb.core.label="grd06" org.eventb.core.predicate="processes_of_partition(proc) = part"/>
<org.eventb.core.guard name="_kYBtdNl5EeO0qb61sEhIIg" org.eventb.core.label="grd30" org.eventb.core.predicate="partition_mode(part) = PM_NORMAL"/>
<org.eventb.core.guard name="_Ci1tc9NfEeOzJJnArOuL7g" org.eventb.core.label="grd40" org.eventb.core.predicate="current_process_flag = TRUE ∧ current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_Ci1tdNNfEeOzJJnArOuL7g" org.eventb.core.label="grd42" org.eventb.core.predicate="proc = current_process"/>
<org.eventb.core.guard name="_Ci1tddNfEeOzJJnArOuL7g" org.eventb.core.label="grd43" org.eventb.core.predicate="(part∉dom(errorhandler_of_partition) ∨ proc ≠ errorhandler_of_partition(part)) ⇒ newlocklevel = {part ↦ 0}"/>
<org.eventb.core.guard name="_3fhcsNgOEeOWS_KGQW7zLA" org.eventb.core.label="grd44" org.eventb.core.predicate="(part∈dom(errorhandler_of_partition) ∧ proc = errorhandler_of_partition(part)) ⇒ newlocklevel = ∅"/>
<org.eventb.core.guard name="_Ci1td9NfEeOzJJnArOuL7g" org.eventb.core.comment="If (current process is the error handler process and preemption is disabled and previous process is not stopped) then return to previous process" org.eventb.core.label="grd45" org.eventb.core.predicate="part∈dom(errorhandler_of_partition) ∧ proc = errorhandler_of_partition(part) ∧ locklevel_of_partition(current_partition) &gt; 0&#10;             ∧ process_state(process_call_errorhandler(proc))≠PS_Dormant ⇒   (newproc = process_call_errorhandler(proc) ∧ resch = FALSE)"/>
<org.eventb.core.guard name="_21vDYNgPEeOWS_KGQW7zLA" org.eventb.core.comment="If (current process is the error handler process and preemption is disabled and previous process is not stopped) then return to previous process" org.eventb.core.label="grd46" org.eventb.core.predicate="¬(part∈dom(errorhandler_of_partition) ∧ proc = errorhandler_of_partition(part) ∧ locklevel_of_partition(current_partition) &gt; 0&#10;             ∧ process_state(process_call_errorhandler(proc))≠PS_Dormant) ⇒   (newproc = proc ∧ resch = TRUE)"/>
<org.eventb.core.guard name="_27vmoNmBEeO0qb61sEhIIg" org.eventb.core.label="grd47" org.eventb.core.predicate="newstate = PS_Dormant"/>
<org.eventb.core.action name="_kYBtddl5EeO0qb61sEhIIg" org.eventb.core.assignment="process_state(proc) ≔ newstate" org.eventb.core.label="act11"/>
<org.eventb.core.action name="_Ci1teNNfEeOzJJnArOuL7g" org.eventb.core.assignment="current_process_flag :∣ (resch = FALSE ⇒ current_process_flag'=TRUE) ∧ (resch = TRUE ⇒ current_process_flag'=FALSE)" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_Ci1tedNfEeOzJJnArOuL7g" org.eventb.core.assignment="locklevel_of_partition ≔  locklevel_of_partition newlocklevel" org.eventb.core.label="act42"/>
<org.eventb.core.action name="_Ci1tetNfEeOzJJnArOuL7g" org.eventb.core.assignment="current_process ≔ newproc" org.eventb.core.label="act43"/>
<org.eventb.core.action name="_Ci1te9NfEeOzJJnArOuL7g" org.eventb.core.assignment="need_reschedule :∣ (resch = TRUE ⇒  need_reschedule' = TRUE) ∧ (resch = FALSE ⇒   need_reschedule' = need_reschedule)" org.eventb.core.label="act44"/>
</org.eventb.core.event>
<org.eventb.core.event name="_QySZY9HYEeOO1v6vzqtXww" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="stop">
<org.eventb.core.refinesEvent name="_QyTAcNHYEeOO1v6vzqtXww" org.eventb.core.target="stop"/>
<org.eventb.core.parameter name="_kYBtdtl5EeO0qb61sEhIIg" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_kYBtd9l5EeO0qb61sEhIIg" org.eventb.core.identifier="proc"/>
<org.eventb.core.parameter name="_kYBteNl5EeO0qb61sEhIIg" org.eventb.core.identifier="newstate"/>
<org.eventb.core.parameter name="_XscjcNNqEeOR94MnZM_MKQ" org.eventb.core.identifier="newlocklevel"/>
<org.eventb.core.guard name="_kYBtedl5EeO0qb61sEhIIg" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS"/>
<org.eventb.core.guard name="_kYBtetl5EeO0qb61sEhIIg" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_kYBte9l5EeO0qb61sEhIIg" org.eventb.core.label="grd03" org.eventb.core.predicate="newstate ∈ PROCESS_STATES"/>
<org.eventb.core.guard name="_kYBtfNl5EeO0qb61sEhIIg" org.eventb.core.label="grd06" org.eventb.core.predicate="processes_of_partition(proc) = part"/>
<org.eventb.core.guard name="_U6F4cNl8EeO0qb61sEhIIg" org.eventb.core.label="grd31" org.eventb.core.predicate="partition_mode(part) = PM_NORMAL ∨ partition_mode(part) = PM_COLD_START ∨ partition_mode(part) = PM_WARM_START"/>
<org.eventb.core.guard name="_XscjcdNqEeOR94MnZM_MKQ" org.eventb.core.label="grd41" org.eventb.core.predicate="current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_XscjctNqEeOR94MnZM_MKQ" org.eventb.core.label="grd42" org.eventb.core.predicate="current_process_flag = TRUE ⇒ proc ≠ current_process"/>
<org.eventb.core.guard name="_Xscjc9NqEeOR94MnZM_MKQ" org.eventb.core.label="grd200" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_XscjdNNqEeOR94MnZM_MKQ" org.eventb.core.label="grd43" org.eventb.core.predicate="process_state(proc) ≠ PS_Dormant"/>
<org.eventb.core.guard name="_3MhfANNqEeOR94MnZM_MKQ" org.eventb.core.label="grd45" org.eventb.core.predicate="(current_process_flag = TRUE ∧ part∈dom(errorhandler_of_partition) ∧ current_process = errorhandler_of_partition(part)&#10;             ∧ proc = process_call_errorhandler(current_process))⇒ newlocklevel = {part ↦ 0}"/>
<org.eventb.core.guard name="_aqoE8NmCEeO0qb61sEhIIg" org.eventb.core.label="grd46" org.eventb.core.predicate="¬(current_process_flag = TRUE ∧ part∈dom(errorhandler_of_partition) ∧ current_process = errorhandler_of_partition(part)&#10;             ∧ proc = process_call_errorhandler(current_process))⇒ newlocklevel = ∅"/>
<org.eventb.core.guard name="_-vpV4NmDEeO0qb61sEhIIg" org.eventb.core.label="grd47" org.eventb.core.predicate="newstate = PS_Dormant"/>
<org.eventb.core.action name="_kYBtfdl5EeO0qb61sEhIIg" org.eventb.core.assignment="process_state(proc) ≔ newstate" org.eventb.core.label="act11"/>
<org.eventb.core.action name="_XscjeNNqEeOR94MnZM_MKQ" org.eventb.core.assignment="locklevel_of_partition ≔  locklevel_of_partition newlocklevel" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_3MhfAdNqEeOR94MnZM_MKQ" org.eventb.core.assignment="timeout_trigger ≔  {proc}⩤ timeout_trigger" org.eventb.core.comment="need to add statement of remove proc from deadlinetime, releasepoint, delaytime,errorhandler, process_call_errorhandler" org.eventb.core.label="act42"/>
</org.eventb.core.event>
<org.eventb.core.event name="_B6kwkNOAEeO526X6vFd9Uw" org.eventb.core.comment="start an aperiodic process in COLD_START or WARM_START mode&#10;extends start" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="start_aperiodprocess_instart">
<org.eventb.core.refinesEvent name="_B6kwkdOAEeO526X6vFd9Uw" org.eventb.core.target="start"/>
<org.eventb.core.parameter name="_-K1kMNl5EeO0qb61sEhIIg" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_-K1kMdl5EeO0qb61sEhIIg" org.eventb.core.identifier="proc"/>
<org.eventb.core.parameter name="_-K1kMtl5EeO0qb61sEhIIg" org.eventb.core.identifier="newstate"/>
<org.eventb.core.guard name="_-K1kM9l5EeO0qb61sEhIIg" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS"/>
<org.eventb.core.guard name="_-K1kNNl5EeO0qb61sEhIIg" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_-K1kNdl5EeO0qb61sEhIIg" org.eventb.core.label="grd03" org.eventb.core.predicate="newstate ∈ PROCESS_STATES"/>
<org.eventb.core.guard name="_-K1kNtl5EeO0qb61sEhIIg" org.eventb.core.label="grd06" org.eventb.core.predicate="processes_of_partition(proc) = part"/>
<org.eventb.core.guard name="_B6kwktOAEeO526X6vFd9Uw" org.eventb.core.label="grd41" org.eventb.core.predicate="current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_B6kwlNOAEeO526X6vFd9Uw" org.eventb.core.label="grd40" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_B6kwldOAEeO526X6vFd9Uw" org.eventb.core.label="grd43" org.eventb.core.predicate="partition_mode(part) = PM_COLD_START ∨  partition_mode(part) = PM_WARM_START"/>
<org.eventb.core.guard name="_B6kwltOAEeO526X6vFd9Uw" org.eventb.core.label="grd44" org.eventb.core.predicate="process_state(proc) = PS_Dormant"/>
<org.eventb.core.guard name="_B6kwl9OAEeO526X6vFd9Uw" org.eventb.core.label="grd45" org.eventb.core.predicate="newstate = PS_Waiting"/>
<org.eventb.core.guard name="_Mc-YUNOAEeO526X6vFd9Uw" org.eventb.core.label="grd46" org.eventb.core.predicate="period_of_process(proc) = INFINITE_TIME_VALUE"/>
<org.eventb.core.action name="_-K1kN9l5EeO0qb61sEhIIg" org.eventb.core.assignment="process_state(proc) ≔ newstate" org.eventb.core.label="act11"/>
<org.eventb.core.action name="_B6kwmdOAEeO526X6vFd9Uw" org.eventb.core.assignment="currentpriority_of_process(proc) ≔ basepriority_of_process(proc)" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_3L6lUNjsEeOECofMeZ85HQ" org.eventb.core.assignment="process_wait_type(proc) ≔ PROC_WAIT_PARTITIONNORMAL" org.eventb.core.label="act42"/>
</org.eventb.core.event>
<org.eventb.core.event name="_B6kwmtOAEeO526X6vFd9Uw" org.eventb.core.comment="start an aperiodic process in NORMAL mode&#10;extends start" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="start_aperiodprocess_innormal">
<org.eventb.core.refinesEvent name="_B6kwm9OAEeO526X6vFd9Uw" org.eventb.core.target="start"/>
<org.eventb.core.parameter name="_-K1kONl5EeO0qb61sEhIIg" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_-K1kOdl5EeO0qb61sEhIIg" org.eventb.core.identifier="proc"/>
<org.eventb.core.parameter name="_-K1kOtl5EeO0qb61sEhIIg" org.eventb.core.identifier="newstate"/>
<org.eventb.core.guard name="_-K1kO9l5EeO0qb61sEhIIg" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS"/>
<org.eventb.core.guard name="_-K1kPNl5EeO0qb61sEhIIg" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_-K1kPdl5EeO0qb61sEhIIg" org.eventb.core.label="grd03" org.eventb.core.predicate="newstate ∈ PROCESS_STATES"/>
<org.eventb.core.guard name="_-K1kPtl5EeO0qb61sEhIIg" org.eventb.core.label="grd06" org.eventb.core.predicate="processes_of_partition(proc) = part"/>
<org.eventb.core.guard name="_B6kwnNOAEeO526X6vFd9Uw" org.eventb.core.label="grd41" org.eventb.core.predicate="current_process_flag = TRUE ∧ current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_3aeUoNPcEeOMAMAP7c_48Q" org.eventb.core.label="grd40" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_B6kwntOAEeO526X6vFd9Uw" org.eventb.core.label="grd43" org.eventb.core.predicate="partition_mode(part) = PM_NORMAL"/>
<org.eventb.core.guard name="_B6kwn9OAEeO526X6vFd9Uw" org.eventb.core.label="grd44" org.eventb.core.predicate="process_state(proc) = PS_Dormant"/>
<org.eventb.core.guard name="_B6kwoNOAEeO526X6vFd9Uw" org.eventb.core.label="grd45" org.eventb.core.predicate="newstate = PS_Ready"/>
<org.eventb.core.guard name="_fITPANOAEeO526X6vFd9Uw" org.eventb.core.label="grd47" org.eventb.core.predicate="period_of_process(proc) = INFINITE_TIME_VALUE"/>
<org.eventb.core.action name="_-K1kP9l5EeO0qb61sEhIIg" org.eventb.core.assignment="process_state(proc) ≔ newstate" org.eventb.core.label="act11"/>
<org.eventb.core.action name="_B6kwo9OAEeO526X6vFd9Uw" org.eventb.core.assignment="currentpriority_of_process(proc) ≔ basepriority_of_process(proc)" org.eventb.core.label="act03"/>
<org.eventb.core.action name="_B6kwpNOAEeO526X6vFd9Uw" org.eventb.core.assignment="deadlinetime_of_process(proc) ≔  clock_tick∗ ONE_TICK_TIME + timecapacity_of_process(proc)" org.eventb.core.label="act04"/>
<org.eventb.core.action name="_B6kwpdOAEeO526X6vFd9Uw" org.eventb.core.assignment="need_reschedule :∣ (locklevel_of_partition(part) =0 ⇒ need_reschedule'=TRUE)&#10;             ∧ (locklevel_of_partition(part) &gt; 0 ⇒ need_reschedule'=need_reschedule)" org.eventb.core.label="act05"/>
</org.eventb.core.event>
<org.eventb.core.event name="_B6kwptOAEeO526X6vFd9Uw" org.eventb.core.comment="start a periodic process in COLD_START or WARM_START mode&#10;extends start" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="start_periodprocess_instart">
<org.eventb.core.refinesEvent name="_B6kwp9OAEeO526X6vFd9Uw" org.eventb.core.target="start"/>
<org.eventb.core.parameter name="_-K1kQNl5EeO0qb61sEhIIg" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_-K1kQdl5EeO0qb61sEhIIg" org.eventb.core.identifier="proc"/>
<org.eventb.core.parameter name="_-K1kQtl5EeO0qb61sEhIIg" org.eventb.core.identifier="newstate"/>
<org.eventb.core.guard name="_-K1kQ9l5EeO0qb61sEhIIg" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS"/>
<org.eventb.core.guard name="_-K1kRNl5EeO0qb61sEhIIg" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_-K1kRdl5EeO0qb61sEhIIg" org.eventb.core.label="grd03" org.eventb.core.predicate="newstate ∈ PROCESS_STATES"/>
<org.eventb.core.guard name="_-K1kRtl5EeO0qb61sEhIIg" org.eventb.core.label="grd06" org.eventb.core.predicate="processes_of_partition(proc) = part"/>
<org.eventb.core.guard name="_2h6ZwNOAEeO526X6vFd9Uw" org.eventb.core.label="grd41" org.eventb.core.predicate="current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_2h6ZwdOAEeO526X6vFd9Uw" org.eventb.core.label="grd40" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_2h6ZwtOAEeO526X6vFd9Uw" org.eventb.core.label="grd42" org.eventb.core.predicate="partition_mode(part) = PM_COLD_START ∨  partition_mode(part) = PM_WARM_START"/>
<org.eventb.core.guard name="_B6kwqdOAEeO526X6vFd9Uw" org.eventb.core.label="grd43" org.eventb.core.predicate="process_state(proc) = PS_Dormant"/>
<org.eventb.core.guard name="_B6uhkNOAEeO526X6vFd9Uw" org.eventb.core.label="grd44" org.eventb.core.predicate="newstate = PS_Waiting"/>
<org.eventb.core.guard name="_2h6Zw9OAEeO526X6vFd9Uw" org.eventb.core.label="grd45" org.eventb.core.predicate="period_of_process(proc) ≠ INFINITE_TIME_VALUE"/>
<org.eventb.core.action name="_-K1kR9l5EeO0qb61sEhIIg" org.eventb.core.assignment="process_state(proc) ≔ newstate" org.eventb.core.label="act11"/>
<org.eventb.core.action name="_B6uhk9OAEeO526X6vFd9Uw" org.eventb.core.assignment="currentpriority_of_process(proc) ≔ basepriority_of_process(proc)" org.eventb.core.label="act03"/>
<org.eventb.core.action name="_i1C3INnOEeOFDPcfaBpwCA" org.eventb.core.assignment="process_wait_type(proc) ≔ PROC_WAIT_PARTITIONNORMAL" org.eventb.core.label="act42"/>
</org.eventb.core.event>
<org.eventb.core.event name="_LInYANOBEeO526X6vFd9Uw" org.eventb.core.comment="start a periodic process in NORMAL mode&#10;extends start" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="start_periodprocess_innormal">
<org.eventb.core.refinesEvent name="_LInYAdOBEeO526X6vFd9Uw" org.eventb.core.target="start"/>
<org.eventb.core.parameter name="_-K1kSNl5EeO0qb61sEhIIg" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_-K1kSdl5EeO0qb61sEhIIg" org.eventb.core.identifier="proc"/>
<org.eventb.core.parameter name="_-K1kStl5EeO0qb61sEhIIg" org.eventb.core.identifier="newstate"/>
<org.eventb.core.parameter name="_LInYAtOBEeO526X6vFd9Uw" org.eventb.core.identifier="fstrl"/>
<org.eventb.core.guard name="_-K1kS9l5EeO0qb61sEhIIg" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS"/>
<org.eventb.core.guard name="_-K1kTNl5EeO0qb61sEhIIg" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_-K1kTdl5EeO0qb61sEhIIg" org.eventb.core.label="grd03" org.eventb.core.predicate="newstate ∈ PROCESS_STATES"/>
<org.eventb.core.guard name="_-K1kTtl5EeO0qb61sEhIIg" org.eventb.core.label="grd06" org.eventb.core.predicate="processes_of_partition(proc) = part"/>
<org.eventb.core.guard name="_LInYA9OBEeO526X6vFd9Uw" org.eventb.core.label="grd41" org.eventb.core.predicate="current_process_flag = TRUE ∧ current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_3aeUodPcEeOMAMAP7c_48Q" org.eventb.core.label="grd40" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_LInYBdOBEeO526X6vFd9Uw" org.eventb.core.label="grd43" org.eventb.core.predicate="partition_mode(part) = PM_NORMAL"/>
<org.eventb.core.guard name="_LInYBtOBEeO526X6vFd9Uw" org.eventb.core.label="grd44" org.eventb.core.predicate="process_state(proc) = PS_Dormant"/>
<org.eventb.core.guard name="_LIxJANOBEeO526X6vFd9Uw" org.eventb.core.label="grd45" org.eventb.core.predicate="newstate = PS_Waiting"/>
<org.eventb.core.guard name="_LIxJAdOBEeO526X6vFd9Uw" org.eventb.core.label="grd46" org.eventb.core.predicate="fstrl ∈ ℕ1"/>
<org.eventb.core.guard name="_LIxJAtOBEeO526X6vFd9Uw" org.eventb.core.label="grd47" org.eventb.core.predicate="period_of_process(proc) ≠ INFINITE_TIME_VALUE"/>
<org.eventb.core.guard name="_LIxJA9OBEeO526X6vFd9Uw" org.eventb.core.label="grd48" org.eventb.core.predicate="∃x,y,b·( ((x↦y)↦b)= firstperiodicprocstart_timeWindow_of_Partition(part)⇒ fstrl= ((clock_tick∗ONE_TICK_TIME)÷majorFrame+1)∗majorFrame + x)"/>
<org.eventb.core.action name="_-K_VMNl5EeO0qb61sEhIIg" org.eventb.core.assignment="process_state(proc) ≔ newstate" org.eventb.core.label="act11"/>
<org.eventb.core.action name="_LIxJBNOBEeO526X6vFd9Uw" org.eventb.core.assignment="currentpriority_of_process(proc) ≔ basepriority_of_process(proc)" org.eventb.core.label="act03"/>
<org.eventb.core.action name="_LIxJBdOBEeO526X6vFd9Uw" org.eventb.core.assignment="releasepoint_of_process(proc) ≔ fstrl" org.eventb.core.label="act05"/>
<org.eventb.core.action name="_LIxJBtOBEeO526X6vFd9Uw" org.eventb.core.assignment="deadlinetime_of_process(proc) ≔  fstrl + timecapacity_of_process(proc)" org.eventb.core.label="act04"/>
<org.eventb.core.action name="_i1C3IdnOEeOFDPcfaBpwCA" org.eventb.core.assignment="process_wait_type(proc) ≔ PROC_WAIT_PERIOD" org.eventb.core.label="act42"/>
</org.eventb.core.event>
<org.eventb.core.event name="_tIp0QNOUEeO0YLhOx7FpMw" org.eventb.core.comment="extends delayed_start" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="delaystart_aperiodprocess_instart">
<org.eventb.core.refinesEvent name="_xaF90DVIEeSxw-wt7-_VGQ" org.eventb.core.target="delayed_start"/>
<org.eventb.core.parameter name="_XbJK0Nl6EeO0qb61sEhIIg" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_XbJK0dl6EeO0qb61sEhIIg" org.eventb.core.identifier="proc"/>
<org.eventb.core.parameter name="_XbJK0tl6EeO0qb61sEhIIg" org.eventb.core.identifier="newstate"/>
<org.eventb.core.parameter name="_tIp0QtOUEeO0YLhOx7FpMw" org.eventb.core.identifier="delaytime"/>
<org.eventb.core.guard name="_XbJK09l6EeO0qb61sEhIIg" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS"/>
<org.eventb.core.guard name="_XbJK1Nl6EeO0qb61sEhIIg" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_XbJK1dl6EeO0qb61sEhIIg" org.eventb.core.label="grd03" org.eventb.core.predicate="newstate ∈ PROCESS_STATES"/>
<org.eventb.core.guard name="_XbJK1tl6EeO0qb61sEhIIg" org.eventb.core.label="grd06" org.eventb.core.predicate="processes_of_partition(proc) = part"/>
<org.eventb.core.guard name="_tIp0Q9OUEeO0YLhOx7FpMw" org.eventb.core.label="grd400" org.eventb.core.predicate="delaytime ∈ ℕ ∧ delaytime≠INFINITE_TIME_VALUE"/>
<org.eventb.core.guard name="_NuEnQNOVEeO0YLhOx7FpMw" org.eventb.core.label="grd41" org.eventb.core.predicate="current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_NuEnQdOVEeO0YLhOx7FpMw" org.eventb.core.label="grd40" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_NuNxMNOVEeO0YLhOx7FpMw" org.eventb.core.label="grd43" org.eventb.core.predicate="partition_mode(part) = PM_COLD_START ∨  partition_mode(part) = PM_WARM_START"/>
<org.eventb.core.guard name="_tIp0RdOUEeO0YLhOx7FpMw" org.eventb.core.label="grd44" org.eventb.core.predicate="process_state(proc) = PS_Dormant"/>
<org.eventb.core.guard name="_tIp0RtOUEeO0YLhOx7FpMw" org.eventb.core.label="grd45" org.eventb.core.predicate="newstate = PS_Waiting"/>
<org.eventb.core.guard name="_NuNxMdOVEeO0YLhOx7FpMw" org.eventb.core.label="grd46" org.eventb.core.predicate="period_of_process(proc) = INFINITE_TIME_VALUE"/>
<org.eventb.core.action name="_XbJK19l6EeO0qb61sEhIIg" org.eventb.core.assignment="process_state(proc) ≔ newstate" org.eventb.core.label="act11"/>
<org.eventb.core.action name="_tIp0SdOUEeO0YLhOx7FpMw" org.eventb.core.assignment="currentpriority_of_process(proc) ≔ basepriority_of_process(proc)" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_Tmm2BtOXEeO0YLhOx7FpMw" org.eventb.core.assignment="process_wait_type(proc)≔PROC_WAIT_DELAY" org.eventb.core.label="act42"/>
<org.eventb.core.action name="_Tmm2B9OXEeO0YLhOx7FpMw" org.eventb.core.assignment="delaytime_of_process(proc) ≔   delaytime" org.eventb.core.label="act43"/>
</org.eventb.core.event>
<org.eventb.core.event name="_tIp0StOUEeO0YLhOx7FpMw" org.eventb.core.comment="if delaytime=0, then immediately transit to READY, this is modelled in start_aperiod_process_whennormal&#10;extends delayed_start&#10;any delaytime" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="delaystart_aperiodprocess_innormal">
<org.eventb.core.refinesEvent name="_xaF90TVIEeSxw-wt7-_VGQ" org.eventb.core.target="delayed_start"/>
<org.eventb.core.parameter name="_b6Qh0Nl3EeO0qb61sEhIIg" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_b6Qh0dl3EeO0qb61sEhIIg" org.eventb.core.identifier="proc"/>
<org.eventb.core.parameter name="_b6Qh0tl3EeO0qb61sEhIIg" org.eventb.core.identifier="newstate"/>
<org.eventb.core.parameter name="_tIp0TNOUEeO0YLhOx7FpMw" org.eventb.core.identifier="delaytime"/>
<org.eventb.core.guard name="_b6Qh09l3EeO0qb61sEhIIg" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS"/>
<org.eventb.core.guard name="_b6Qh1Nl3EeO0qb61sEhIIg" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_b6Qh1dl3EeO0qb61sEhIIg" org.eventb.core.label="grd03" org.eventb.core.predicate="newstate ∈ PROCESS_STATES"/>
<org.eventb.core.guard name="_b6Qh1tl3EeO0qb61sEhIIg" org.eventb.core.label="grd06" org.eventb.core.predicate="processes_of_partition(proc) = part"/>
<org.eventb.core.guard name="_VWEd8NOWEeO0YLhOx7FpMw" org.eventb.core.label="grd40" org.eventb.core.predicate="delaytime &gt; 0 ∧ delaytime≠INFINITE_TIME_VALUE"/>
<org.eventb.core.guard name="_VWEd8dOWEeO0YLhOx7FpMw" org.eventb.core.label="grd41" org.eventb.core.predicate="current_process_flag = TRUE ∧ current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_3anekNPcEeOMAMAP7c_48Q" org.eventb.core.label="grd42" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_tIp0UNOUEeO0YLhOx7FpMw" org.eventb.core.label="grd43" org.eventb.core.predicate="partition_mode(part) = PM_NORMAL"/>
<org.eventb.core.guard name="_VWEd8tOWEeO0YLhOx7FpMw" org.eventb.core.label="grd44" org.eventb.core.predicate="process_state(proc) = PS_Dormant"/>
<org.eventb.core.guard name="_tIp0UtOUEeO0YLhOx7FpMw" org.eventb.core.label="grd45" org.eventb.core.predicate="newstate = PS_Waiting"/>
<org.eventb.core.guard name="_VWEd89OWEeO0YLhOx7FpMw" org.eventb.core.label="grd47" org.eventb.core.predicate="period_of_process(proc) = INFINITE_TIME_VALUE"/>
<org.eventb.core.action name="_kYLecNl5EeO0qb61sEhIIg" org.eventb.core.assignment="process_state(proc) ≔ newstate" org.eventb.core.label="act11"/>
<org.eventb.core.action name="_tIp0VdOUEeO0YLhOx7FpMw" org.eventb.core.assignment="currentpriority_of_process(proc) ≔ basepriority_of_process(proc)" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_tIp0VtOUEeO0YLhOx7FpMw" org.eventb.core.assignment="deadlinetime_of_process(proc) ≔  clock_tick∗ ONE_TICK_TIME + timecapacity_of_process(proc) + delaytime" org.eventb.core.label="act42"/>
<org.eventb.core.action name="_tIp0V9OUEeO0YLhOx7FpMw" org.eventb.core.assignment="timeout_trigger ≔  timeout_trigger  {proc ↦ (PS_Ready↦ (delaytime +clock_tick ∗ ONE_TICK_TIME))}" org.eventb.core.label="act43"/>
<org.eventb.core.action name="_tIp0WNOUEeO0YLhOx7FpMw" org.eventb.core.assignment="need_reschedule :∣ (locklevel_of_partition(part) =0 ⇒ need_reschedule'=TRUE)&#10;             ∧ (locklevel_of_partition(part) &gt; 0 ⇒ need_reschedule'=need_reschedule)" org.eventb.core.label="act44"/>
<org.eventb.core.action name="_kVspgNOXEeO0YLhOx7FpMw" org.eventb.core.assignment="process_wait_type(proc)≔PROC_WAIT_DELAY" org.eventb.core.label="act45"/>
<org.eventb.core.action name="_kVspgdOXEeO0YLhOx7FpMw" org.eventb.core.assignment="delaytime_of_process(proc) ≔   delaytime" org.eventb.core.label="act46"/>
</org.eventb.core.event>
<org.eventb.core.event name="_tIp0WdOUEeO0YLhOx7FpMw" org.eventb.core.comment="extends delayed_start" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="delaystart_periodprocess_instart">
<org.eventb.core.refinesEvent name="_Fcq1kDJ7EeSQ7c4olNszIw" org.eventb.core.target="delayed_start"/>
<org.eventb.core.parameter name="_XbJK2Nl6EeO0qb61sEhIIg" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_XbJK2dl6EeO0qb61sEhIIg" org.eventb.core.identifier="proc"/>
<org.eventb.core.parameter name="_XbJK2tl6EeO0qb61sEhIIg" org.eventb.core.identifier="newstate"/>
<org.eventb.core.parameter name="_tIp0W9OUEeO0YLhOx7FpMw" org.eventb.core.identifier="delaytime"/>
<org.eventb.core.guard name="_XbS70Nl6EeO0qb61sEhIIg" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS"/>
<org.eventb.core.guard name="_XbS70dl6EeO0qb61sEhIIg" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_XbS70tl6EeO0qb61sEhIIg" org.eventb.core.label="grd03" org.eventb.core.predicate="newstate ∈ PROCESS_STATES"/>
<org.eventb.core.guard name="_XbS709l6EeO0qb61sEhIIg" org.eventb.core.label="grd06" org.eventb.core.predicate="processes_of_partition(proc) = part"/>
<org.eventb.core.guard name="_TmdFANOXEeO0YLhOx7FpMw" org.eventb.core.label="grd400" org.eventb.core.predicate="delaytime ∈ ℕ ∧ delaytime≠INFINITE_TIME_VALUE ∧ delaytime &lt; period_of_process(proc)"/>
<org.eventb.core.guard name="_TmdFAdOXEeO0YLhOx7FpMw" org.eventb.core.label="grd41" org.eventb.core.predicate="current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_TmdFAtOXEeO0YLhOx7FpMw" org.eventb.core.label="grd40" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_tIp0XNOUEeO0YLhOx7FpMw" org.eventb.core.label="grd42" org.eventb.core.predicate="partition_mode(part) = PM_COLD_START ∨  partition_mode(part) = PM_WARM_START"/>
<org.eventb.core.guard name="_tIp0XtOUEeO0YLhOx7FpMw" org.eventb.core.label="grd43" org.eventb.core.predicate="process_state(proc) = PS_Dormant"/>
<org.eventb.core.guard name="_tIp0X9OUEeO0YLhOx7FpMw" org.eventb.core.label="grd44" org.eventb.core.predicate="newstate = PS_Waiting"/>
<org.eventb.core.guard name="_Tmm2ANOXEeO0YLhOx7FpMw" org.eventb.core.label="grd45" org.eventb.core.predicate="period_of_process(proc) ≠ INFINITE_TIME_VALUE"/>
<org.eventb.core.action name="_XbS71Nl6EeO0qb61sEhIIg" org.eventb.core.assignment="process_state(proc) ≔ newstate" org.eventb.core.label="act11"/>
<org.eventb.core.action name="_tIp0YtOUEeO0YLhOx7FpMw" org.eventb.core.assignment="currentpriority_of_process(proc) ≔ basepriority_of_process(proc)" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_Tmm2AdOXEeO0YLhOx7FpMw" org.eventb.core.assignment="process_wait_type(proc)≔PROC_WAIT_DELAY" org.eventb.core.label="act42"/>
<org.eventb.core.action name="_Tmm2AtOXEeO0YLhOx7FpMw" org.eventb.core.assignment="delaytime_of_process(proc) ≔   delaytime" org.eventb.core.label="act43"/>
</org.eventb.core.event>
<org.eventb.core.event name="_tIp0Y9OUEeO0YLhOx7FpMw" org.eventb.core.comment="extends delayed_start" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="delaystart_periodprocess_innormal">
<org.eventb.core.refinesEvent name="_qlGXkCtmEeSCDLsjAFWqoQ" org.eventb.core.target="delayed_start"/>
<org.eventb.core.parameter name="_XbS71dl6EeO0qb61sEhIIg" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_XbS71tl6EeO0qb61sEhIIg" org.eventb.core.identifier="proc"/>
<org.eventb.core.parameter name="_XbS719l6EeO0qb61sEhIIg" org.eventb.core.identifier="newstate"/>
<org.eventb.core.parameter name="_tIp0ZdOUEeO0YLhOx7FpMw" org.eventb.core.identifier="delaytime"/>
<org.eventb.core.parameter name="_tIp0ZtOUEeO0YLhOx7FpMw" org.eventb.core.identifier="fstrl"/>
<org.eventb.core.guard name="_XbS72Nl6EeO0qb61sEhIIg" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS"/>
<org.eventb.core.guard name="_XbS72dl6EeO0qb61sEhIIg" org.eventb.core.label="grd02" org.eventb.core.predicate="proc ∈ processes"/>
<org.eventb.core.guard name="_XbS72tl6EeO0qb61sEhIIg" org.eventb.core.label="grd03" org.eventb.core.predicate="newstate ∈ PROCESS_STATES"/>
<org.eventb.core.guard name="_XbS729l6EeO0qb61sEhIIg" org.eventb.core.label="grd06" org.eventb.core.predicate="processes_of_partition(proc) = part"/>
<org.eventb.core.guard name="_tIp0aNOUEeO0YLhOx7FpMw" org.eventb.core.label="grd41" org.eventb.core.predicate="delaytime ∈ ℕ ∧ delaytime≠INFINITE_TIME_VALUE ∧ delaytime &lt; period_of_process(proc)"/>
<org.eventb.core.guard name="_YMyW8NOXEeO0YLhOx7FpMw" org.eventb.core.label="grd42" org.eventb.core.predicate="current_process_flag = TRUE ∧ current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_3anekdPcEeOMAMAP7c_48Q" org.eventb.core.label="grd40" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_tIp0atOUEeO0YLhOx7FpMw" org.eventb.core.label="grd43" org.eventb.core.predicate="partition_mode(part) = PM_NORMAL"/>
<org.eventb.core.guard name="_tIp0a9OUEeO0YLhOx7FpMw" org.eventb.core.label="grd44" org.eventb.core.predicate="process_state(proc) = PS_Dormant"/>
<org.eventb.core.guard name="_tIp0bNOUEeO0YLhOx7FpMw" org.eventb.core.label="grd45" org.eventb.core.predicate="newstate = PS_Waiting"/>
<org.eventb.core.guard name="_Tmm2A9OXEeO0YLhOx7FpMw" org.eventb.core.label="grd46" org.eventb.core.predicate="fstrl ∈ ℕ1"/>
<org.eventb.core.guard name="_Tmm2BNOXEeO0YLhOx7FpMw" org.eventb.core.label="grd47" org.eventb.core.predicate="period_of_process(proc) ≠ INFINITE_TIME_VALUE"/>
<org.eventb.core.guard name="_Tmm2BdOXEeO0YLhOx7FpMw" org.eventb.core.label="grd48" org.eventb.core.predicate="∃x,y,b·( ((x↦y)↦b)= firstperiodicprocstart_timeWindow_of_Partition(part)⇒ fstrl= ((clock_tick∗ONE_TICK_TIME)÷majorFrame+1)∗majorFrame + x)"/>
<org.eventb.core.action name="_XbS73Nl6EeO0qb61sEhIIg" org.eventb.core.assignment="process_state(proc) ≔ newstate" org.eventb.core.label="act11"/>
<org.eventb.core.action name="_tIzlQtOUEeO0YLhOx7FpMw" org.eventb.core.assignment="currentpriority_of_process(proc) ≔ basepriority_of_process(proc)" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_tIzlQ9OUEeO0YLhOx7FpMw" org.eventb.core.assignment="releasepoint_of_process(proc) ≔ fstrl + delaytime" org.eventb.core.label="act42"/>
<org.eventb.core.action name="_tIzlRNOUEeO0YLhOx7FpMw" org.eventb.core.assignment="deadlinetime_of_process(proc) ≔  fstrl +delaytime + timecapacity_of_process(proc)" org.eventb.core.label="act43"/>
<org.eventb.core.action name="_kV2agNOXEeO0YLhOx7FpMw" org.eventb.core.assignment="process_wait_type(proc)≔PROC_WAIT_DELAY" org.eventb.core.label="act45"/>
<org.eventb.core.action name="_kV2agdOXEeO0YLhOx7FpMw" org.eventb.core.assignment="delaytime_of_process(proc) ≔   delaytime" org.eventb.core.label="act46"/>
</org.eventb.core.event>
<org.eventb.core.event name="_sjczMdHYEeOO1v6vzqtXww" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="lock_preemption">
<org.eventb.core.parameter name="_g0Fd8NPZEeOMAMAP7c_48Q" org.eventb.core.identifier="part"/>
<org.eventb.core.guard name="_g0Fd8dPZEeOMAMAP7c_48Q" org.eventb.core.label="grd0" org.eventb.core.predicate="current_process_flag = TRUE ∧ current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_g0Fd8tPZEeOMAMAP7c_48Q" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS ∧ part = current_partition"/>
<org.eventb.core.guard name="_g0Fd89PZEeOMAMAP7c_48Q" org.eventb.core.label="grd02" org.eventb.core.predicate="part∈dom(errorhandler_of_partition) ⇒ current_process ≠ errorhandler_of_partition(part)"/>
<org.eventb.core.guard name="_g0Fd9NPZEeOMAMAP7c_48Q" org.eventb.core.label="grd03" org.eventb.core.predicate="partition_mode(part) = PM_NORMAL"/>
<org.eventb.core.guard name="_g0Fd9dPZEeOMAMAP7c_48Q" org.eventb.core.label="grd04" org.eventb.core.predicate="locklevel_of_partition(part) &lt; MAX_LOCK_LEVEL"/>
<org.eventb.core.action name="_g0Fd9tPZEeOMAMAP7c_48Q" org.eventb.core.assignment="locklevel_of_partition(part) ≔ locklevel_of_partition(part) + 1" org.eventb.core.label="act01"/>
<org.eventb.core.action name="_4A4B4NdAEeOuG80hxTAROw" org.eventb.core.assignment="preempter_of_partition(part) ≔ current_process" org.eventb.core.label="act02"/>
</org.eventb.core.event>
<org.eventb.core.event name="_sjdaQNHYEeOO1v6vzqtXww" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="unlock_preemption">
<org.eventb.core.parameter name="_3XGX4NPZEeOMAMAP7c_48Q" org.eventb.core.identifier="part"/>
<org.eventb.core.parameter name="_3XGX4dPZEeOMAMAP7c_48Q" org.eventb.core.identifier="resched"/>
<org.eventb.core.parameter name="_4A4B4ddAEeOuG80hxTAROw" org.eventb.core.identifier="preempter"/>
<org.eventb.core.guard name="_3XGX4tPZEeOMAMAP7c_48Q" org.eventb.core.label="grd0" org.eventb.core.predicate="current_process_flag = TRUE ∧ current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_3XGX49PZEeOMAMAP7c_48Q" org.eventb.core.label="grd01" org.eventb.core.predicate="part ∈ PARTITIONS ∧ part = current_partition"/>
<org.eventb.core.guard name="_3XGX5NPZEeOMAMAP7c_48Q" org.eventb.core.label="grd02" org.eventb.core.predicate="part∈dom(errorhandler_of_partition) ⇒ current_process ≠ errorhandler_of_partition(part)"/>
<org.eventb.core.guard name="_3XGX5dPZEeOMAMAP7c_48Q" org.eventb.core.label="grd03" org.eventb.core.predicate="partition_mode(part) = PM_NORMAL"/>
<org.eventb.core.guard name="_3XGX5tPZEeOMAMAP7c_48Q" org.eventb.core.label="grd04" org.eventb.core.predicate="locklevel_of_partition(part) &gt; 0"/>
<org.eventb.core.guard name="_3XGX59PZEeOMAMAP7c_48Q" org.eventb.core.label="grd05" org.eventb.core.predicate="locklevel_of_partition(part) = 1 ⇒ resched = TRUE"/>
<org.eventb.core.guard name="_3XGX6NPZEeOMAMAP7c_48Q" org.eventb.core.label="grd06" org.eventb.core.predicate="locklevel_of_partition(part) &gt; 1 ⇒ resched = FALSE"/>
<org.eventb.core.guard name="_4A4B4tdAEeOuG80hxTAROw" org.eventb.core.label="grd07" org.eventb.core.predicate="locklevel_of_partition(part) = 1 ⇒ preempter = {(part ↦ current_process)}"/>
<org.eventb.core.guard name="_4A4B49dAEeOuG80hxTAROw" org.eventb.core.label="grd08" org.eventb.core.predicate="locklevel_of_partition(part) &gt; 1 ⇒ preempter = ∅"/>
<org.eventb.core.action name="_3XGX6dPZEeOMAMAP7c_48Q" org.eventb.core.assignment="locklevel_of_partition(part) ≔ locklevel_of_partition(part) − 1" org.eventb.core.label="act01"/>
<org.eventb.core.action name="_3XGX6tPZEeOMAMAP7c_48Q" org.eventb.core.assignment="need_reschedule :∣ (resched = TRUE ⇒ need_reschedule'=TRUE)&#10;             ∧ (resched = FALSE ⇒ need_reschedule'=need_reschedule)" org.eventb.core.label="act02"/>
<org.eventb.core.action name="_4A4B5NdAEeOuG80hxTAROw" org.eventb.core.assignment="preempter_of_partition ≔  preempter_of_partition ∖ preempter" org.eventb.core.label="act03"/>
</org.eventb.core.event>
<org.eventb.core.event name="_sjdaQdHYEeOO1v6vzqtXww" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="get_my_id">
<org.eventb.core.guard name="_17wJUNPbEeOMAMAP7c_48Q" org.eventb.core.label="grd0" org.eventb.core.predicate="current_process_flag = TRUE ∧ current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_ENsP0NPaEeOMAMAP7c_48Q" org.eventb.core.label="grd01" org.eventb.core.predicate="current_partition∈dom(errorhandler_of_partition) ⇒ current_process ≠ errorhandler_of_partition(current_partition)"/>
</org.eventb.core.event>
<org.eventb.core.event name="_QyTngNHYEeOO1v6vzqtXww" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="timed_wait">
<org.eventb.core.refinesEvent name="_QyTngdHYEeOO1v6vzqtXww" org.eventb.core.target="timed_wait"/>
<org.eventb.core.parameter name="_3anektPcEeOMAMAP7c_48Q" org.eventb.core.identifier="delaytime"/>
<org.eventb.core.parameter name="_3anek9PcEeOMAMAP7c_48Q" org.eventb.core.identifier="tmout_trig"/>
<org.eventb.core.parameter name="_7c7A8NPdEeOMAMAP7c_48Q" org.eventb.core.identifier="wt"/>
<org.eventb.core.guard name="_3anelNPcEeOMAMAP7c_48Q" org.eventb.core.label="grd40" org.eventb.core.predicate="delaytime ≠ INFINITE_TIME_VALUE"/>
<org.eventb.core.guard name="_3aneldPcEeOMAMAP7c_48Q" org.eventb.core.label="grd41" org.eventb.core.predicate="current_process_flag = TRUE ∧ current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_3aneltPcEeOMAMAP7c_48Q" org.eventb.core.label="grd42" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_3anel9PcEeOMAMAP7c_48Q" org.eventb.core.label="grd43" org.eventb.core.predicate="proc = current_process"/>
<org.eventb.core.guard name="_3anemNPcEeOMAMAP7c_48Q" org.eventb.core.label="grd44" org.eventb.core.predicate="current_partition∈dom(errorhandler_of_partition) ⇒ current_process ≠ errorhandler_of_partition(current_partition)"/>
<org.eventb.core.guard name="_3anemdPcEeOMAMAP7c_48Q" org.eventb.core.label="grd45" org.eventb.core.predicate="locklevel_of_partition(current_partition) = 0"/>
<org.eventb.core.guard name="_3anemtPcEeOMAMAP7c_48Q" org.eventb.core.label="grd36" org.eventb.core.predicate="tmout_trig ∈ processes ⇸ (PROCESS_STATES × ℕ1)"/>
<org.eventb.core.guard name="_3anem9PcEeOMAMAP7c_48Q" org.eventb.core.label="grd37" org.eventb.core.predicate="(delaytime = 0 ⇒ (newstate = PS_Ready ∧ tmout_trig = ∅ ∧ wt=∅))&#10;             ∧ (delaytime &gt;0 ⇒ (newstate = PS_Waiting ∧ wt={proc↦PROC_WAIT_TIMEOUT} ∧ tmout_trig = {current_process↦(PS_Ready↦ (delaytime +clock_tick ∗ ONE_TICK_TIME))}))"/>
<org.eventb.core.action name="_3axPkNPcEeOMAMAP7c_48Q" org.eventb.core.assignment="timeout_trigger ≔ timeout_trigger   tmout_trig" org.eventb.core.label="act05"/>
<org.eventb.core.action name="_7c7A8dPdEeOMAMAP7c_48Q" org.eventb.core.assignment="process_wait_type ≔ process_wait_type  wt" org.eventb.core.label="act04"/>
<org.eventb.core.action name="_3axPkdPcEeOMAMAP7c_48Q" org.eventb.core.assignment="need_reschedule ≔ TRUE" org.eventb.core.label="act06"/>
<org.eventb.core.action name="_ok4wsNPtEeOZBrbXix_W6g" org.eventb.core.assignment="current_process_flag ≔ FALSE" org.eventb.core.label="act07"/>
</org.eventb.core.event>
<org.eventb.core.event name="_QyTngtHYEeOO1v6vzqtXww" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="period_wait">
<org.eventb.core.refinesEvent name="_QyTng9HYEeOO1v6vzqtXww" org.eventb.core.target="period_wait"/>
<org.eventb.core.guard name="_gdJLUNPeEeOMAMAP7c_48Q" org.eventb.core.label="grd40" org.eventb.core.predicate="current_process_flag = TRUE ∧ current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_gdJLUdPeEeOMAMAP7c_48Q" org.eventb.core.label="grd41" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_gdJLUtPeEeOMAMAP7c_48Q" org.eventb.core.label="grd42" org.eventb.core.predicate="proc = current_process"/>
<org.eventb.core.guard name="_gdJLU9PeEeOMAMAP7c_48Q" org.eventb.core.label="grd43" org.eventb.core.predicate="current_partition∈dom(errorhandler_of_partition) ⇒ current_process ≠ errorhandler_of_partition(current_partition)"/>
<org.eventb.core.guard name="_gdJLVNPeEeOMAMAP7c_48Q" org.eventb.core.label="grd44" org.eventb.core.predicate="locklevel_of_partition(current_partition) = 0"/>
<org.eventb.core.guard name="_gdJLVdPeEeOMAMAP7c_48Q" org.eventb.core.comment="requesting process is not aperiodic" org.eventb.core.label="grd45" org.eventb.core.predicate="period_of_process(proc) ≠ INFINITE_TIME_VALUE"/>
<org.eventb.core.action name="_gdJLVtPeEeOMAMAP7c_48Q" org.eventb.core.assignment="releasepoint_of_process(proc) ≔  releasepoint_of_process(proc) + period_of_process(proc)" org.eventb.core.comment="Next release point := process period plus previous release point;&#10;         @act42 nextreleasepoint_of_process(proc) ≔  nextreleasepoint_of_process(proc) + period_of_process(proc) " org.eventb.core.label="act41"/>
<org.eventb.core.action name="_gdJLWNPeEeOMAMAP7c_48Q" org.eventb.core.assignment="deadlinetime_of_process(proc) ≔   releasepoint_of_process(proc) + timecapacity_of_process(proc)" org.eventb.core.label="act43"/>
<org.eventb.core.action name="_gdJLWdPeEeOMAMAP7c_48Q" org.eventb.core.assignment="need_reschedule ≔ TRUE" org.eventb.core.label="act44"/>
<org.eventb.core.action name="_ok4wsdPtEeOZBrbXix_W6g" org.eventb.core.assignment="current_process_flag ≔ FALSE" org.eventb.core.label="act45"/>
</org.eventb.core.event>
<org.eventb.core.event name="_VZSxctPgEeOMAMAP7c_48Q" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="get_time">
<org.eventb.core.guard name="_TlSf8PaMEeO0lIhp9r31mg" org.eventb.core.label="grd01" org.eventb.core.predicate="current_process_flag = TRUE ∧ current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_TlSf8faMEeO0lIhp9r31mg" org.eventb.core.label="grd02" org.eventb.core.predicate="partition_mode(current_partition) = PM_NORMAL"/>
</org.eventb.core.event>
<org.eventb.core.event name="_VZSxc9PgEeOMAMAP7c_48Q" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="replenish">
<org.eventb.core.parameter name="_VZSxdNPgEeOMAMAP7c_48Q" org.eventb.core.identifier="budget_time"/>
<org.eventb.core.parameter name="_VZSxddPgEeOMAMAP7c_48Q" org.eventb.core.identifier="ddtm"/>
<org.eventb.core.guard name="_VZSxdtPgEeOMAMAP7c_48Q" org.eventb.core.label="grd01" org.eventb.core.predicate="budget_time ∈ ℤ"/>
<org.eventb.core.guard name="_VZSxd9PgEeOMAMAP7c_48Q" org.eventb.core.label="grd02" org.eventb.core.predicate="current_process_flag = TRUE ∧ current_partition_flag = TRUE"/>
<org.eventb.core.guard name="_VZSxeNPgEeOMAMAP7c_48Q" org.eventb.core.label="grd03" org.eventb.core.predicate="partition_mode(current_partition) = PM_NORMAL"/>
<org.eventb.core.guard name="_VZSxedPgEeOMAMAP7c_48Q" org.eventb.core.label="grd04" org.eventb.core.predicate="current_partition∈dom(errorhandler_of_partition) ⇒ current_process ≠ errorhandler_of_partition(current_partition)"/>
<org.eventb.core.guard name="_VZSxetPgEeOMAMAP7c_48Q" org.eventb.core.comment="requesting process is not aperiodic&#10;         requesting process is aperiodic or new deadline will not exceed next release point " org.eventb.core.label="grd05" org.eventb.core.predicate="period_of_process(current_process) ≠ INFINITE_TIME_VALUE&#10;             ∧ clock_tick ∗ ONE_TICK_TIME + budget_time ≤ releasepoint_of_process(current_process)+timecapacity_of_process(current_process)"/>
<org.eventb.core.guard name="_VZSxe9PgEeOMAMAP7c_48Q" org.eventb.core.label="grd06" org.eventb.core.predicate="ddtm∈ℤ"/>
<org.eventb.core.guard name="_VZSxfNPgEeOMAMAP7c_48Q" org.eventb.core.label="grd07" org.eventb.core.predicate="budget_time &gt; 0 ⇒ ddtm = clock_tick ∗ ONE_TICK_TIME + budget_time"/>
<org.eventb.core.guard name="_VZSxfdPgEeOMAMAP7c_48Q" org.eventb.core.label="grd08" org.eventb.core.predicate="(budget_time = INFINITE_TIME_VALUE ∨ timecapacity_of_process(current_process)=INFINITE_TIME_VALUE) ⇒ ddtm = INFINITE_TIME_VALUE"/>
<org.eventb.core.action name="_VZSxftPgEeOMAMAP7c_48Q" org.eventb.core.assignment="deadlinetime_of_process(current_process) ≔ ddtm" org.eventb.core.label="act01"/>
</org.eventb.core.event>
<org.eventb.core.event name="_DcpSwdPtEeOZBrbXix_W6g" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="aperiodicprocess_finished">
<org.eventb.core.refinesEvent name="_FdHhgDJ7EeSQ7c4olNszIw" org.eventb.core.target="process_finished"/>
<org.eventb.core.guard name="_DcycsdPtEeOZBrbXix_W6g" org.eventb.core.label="grd40" org.eventb.core.predicate="current_partition_flag = TRUE ∧ current_process_flag = TRUE"/>
<org.eventb.core.guard name="_DcycstPtEeOZBrbXix_W6g" org.eventb.core.label="grd41" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_Dcycs9PtEeOZBrbXix_W6g" org.eventb.core.label="grd42" org.eventb.core.predicate="proc = current_process"/>
<org.eventb.core.guard name="_DcyctNPtEeOZBrbXix_W6g" org.eventb.core.label="grd44" org.eventb.core.predicate="newstate = PS_Dormant"/>
<org.eventb.core.guard name="_DcyctdPtEeOZBrbXix_W6g" org.eventb.core.label="grd45" org.eventb.core.predicate="period_of_process(proc) = INFINITE_TIME_VALUE"/>
<org.eventb.core.action name="_DcycttPtEeOZBrbXix_W6g" org.eventb.core.assignment="need_reschedule ≔ TRUE" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_ok4wstPtEeOZBrbXix_W6g" org.eventb.core.assignment="current_process_flag ≔ FALSE" org.eventb.core.label="act42"/>
</org.eventb.core.event>
<org.eventb.core.event name="_Dcyct9PtEeOZBrbXix_W6g" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="periodicprocess_finished">
<org.eventb.core.refinesEvent name="_6LtMsP_7EeOGibWoyCWxNQ" org.eventb.core.target="process_finished"/>
<org.eventb.core.guard name="_DcycudPtEeOZBrbXix_W6g" org.eventb.core.label="grd40" org.eventb.core.predicate="current_partition_flag = TRUE ∧ current_process_flag = TRUE"/>
<org.eventb.core.guard name="_DcycutPtEeOZBrbXix_W6g" org.eventb.core.label="grd41" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_Dcycu9PtEeOZBrbXix_W6g" org.eventb.core.label="grd42" org.eventb.core.predicate="proc = current_process"/>
<org.eventb.core.guard name="_DcycvNPtEeOZBrbXix_W6g" org.eventb.core.label="grd44" org.eventb.core.predicate="newstate = PS_Waiting"/>
<org.eventb.core.guard name="_DcycvdPtEeOZBrbXix_W6g" org.eventb.core.label="grd45" org.eventb.core.predicate="period_of_process(proc) ≠ INFINITE_TIME_VALUE"/>
<org.eventb.core.action name="_DcycvtPtEeOZBrbXix_W6g" org.eventb.core.assignment="need_reschedule ≔ TRUE" org.eventb.core.comment="@act42 releasepoint_of_process(proc) ≔  releasepoint_of_process(proc) + timecapacity_of_process(proc)" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_M8YjoNPtEeOZBrbXix_W6g" org.eventb.core.assignment="process_wait_type(proc) ≔ PROC_WAIT_PERIOD" org.eventb.core.label="act43"/>
<org.eventb.core.action name="_ok4ws9PtEeOZBrbXix_W6g" org.eventb.core.assignment="current_process_flag ≔ FALSE" org.eventb.core.label="act44"/>
</org.eventb.core.event>
<org.eventb.core.event name="_7xRpYdK2EeOIk6vzYQGQiQ" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="time_out">
<org.eventb.core.refinesEvent name="_V2-m8NK3EeOIk6vzYQGQiQ" org.eventb.core.target="time_out"/>
<org.eventb.core.parameter name="_Dc58AtPuEeOZBrbXix_W6g" org.eventb.core.comment="time is the absolute time ,not the &quot;timeout&quot;" org.eventb.core.identifier="time"/>
<org.eventb.core.guard name="_Dc58BNPuEeOZBrbXix_W6g" org.eventb.core.label="grd41" org.eventb.core.predicate="proc ∈ dom(timeout_trigger)"/>
<org.eventb.core.guard name="_Dc58BdPuEeOZBrbXix_W6g" org.eventb.core.comment="@grd43 process_state(proc) = PS_Waiting" org.eventb.core.label="grd42" org.eventb.core.predicate="newstate ↦ time = timeout_trigger(proc)"/>
<org.eventb.core.guard name="_Dc58B9PuEeOZBrbXix_W6g" org.eventb.core.comment="when the end time is ellapsed one tick&#10;@grd45 state = newstate" org.eventb.core.label="grd44" org.eventb.core.predicate="time ≥ (clock_tick − 1)∗ONE_TICK_TIME ∧ time ≤ clock_tick∗ONE_TICK_TIME"/>
<org.eventb.core.action name="_S9XBcN4bEeO-CtNfC1ivEA" org.eventb.core.assignment="timeout_trigger ≔ timeout_trigger ∖{proc↦(newstate↦time)}" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_Dc58CdPuEeOZBrbXix_W6g" org.eventb.core.assignment="process_wait_type ≔  {proc} ⩤ process_wait_type" org.eventb.core.label="act42"/>
</org.eventb.core.event>
<org.eventb.core.event name="_m_Bs0OE4EeOlhdB8eyQyLQ" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="req_busy_resource">
<org.eventb.core.refinesEvent name="_m_Bs0eE4EeOlhdB8eyQyLQ" org.eventb.core.target="req_busy_resource"/>
<org.eventb.core.parameter name="_tgRHQOFvEeOlhdB8eyQyLQ" org.eventb.core.identifier="wt"/>
<org.eventb.core.parameter name="_ORWVsOGGEeOlhdB8eyQyLQ" org.eventb.core.identifier="timeout"/>
<org.eventb.core.parameter name="_ORWVseGGEeOlhdB8eyQyLQ" org.eventb.core.identifier="tmout_trig"/>
<org.eventb.core.guard name="_bmuwIOE-EeOlhdB8eyQyLQ" org.eventb.core.label="grd40" org.eventb.core.predicate="current_partition_flag = TRUE ∧ current_process_flag = TRUE"/>
<org.eventb.core.guard name="_bmuwIeE-EeOlhdB8eyQyLQ" org.eventb.core.label="grd41" org.eventb.core.predicate="part = current_partition"/>
<org.eventb.core.guard name="_bmuwIuE-EeOlhdB8eyQyLQ" org.eventb.core.label="grd42" org.eventb.core.predicate="proc = current_process"/>
<org.eventb.core.guard name="_tgRHQeFvEeOlhdB8eyQyLQ" org.eventb.core.comment="@grd06 tmout &gt;0 ∨ tmout = INFINITE_TIME_VALUE&#10;this line is correct, the next line is from ARINC653" org.eventb.core.label="grd43" org.eventb.core.predicate="wt∈PROCESS_WAIT_TYPES ∧ (wt= PROC_WAIT_OBJ ∨ wt=PROC_WAIT_TIMEOUT)"/>
<org.eventb.core.guard name="_ORWVsuGGEeOlhdB8eyQyLQ" org.eventb.core.label="grd44" org.eventb.core.predicate="timeout ≠0"/>
<org.eventb.core.guard name="_ORWVs-GGEeOlhdB8eyQyLQ" org.eventb.core.label="grd45" org.eventb.core.predicate="tmout_trig ∈ processes ⇸ (PROCESS_STATES × ℕ1)"/>
<org.eventb.core.guard name="_ORWVtOGGEeOlhdB8eyQyLQ" org.eventb.core.label="grd46" org.eventb.core.predicate="(timeout = INFINITE_TIME_VALUE ⇒  tmout_trig = ∅)&#10;    &#9;&#9;∧ (timeout ≠INFINITE_TIME_VALUE ⇒ tmout_trig = {proc↦(PS_Ready↦ (timeout +clock_tick ∗ ONE_TICK_TIME))})"/>
<org.eventb.core.guard name="_gO9KwOGGEeOlhdB8eyQyLQ" org.eventb.core.label="grd47" org.eventb.core.predicate="timeout≠INFINITE_TIME_VALUE ⇒ wt = PROC_WAIT_TIMEOUT"/>
<org.eventb.core.guard name="_ORWVtuGGEeOlhdB8eyQyLQ" org.eventb.core.label="grd48" org.eventb.core.predicate="timeout =  INFINITE_TIME_VALUE ⇒ wt = PROC_WAIT_OBJ"/>
<org.eventb.core.action name="_bmuwI-E-EeOlhdB8eyQyLQ" org.eventb.core.assignment="need_reschedule ≔ TRUE" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_bmuwJOE-EeOlhdB8eyQyLQ" org.eventb.core.assignment="current_process_flag ≔ FALSE" org.eventb.core.label="act42"/>
<org.eventb.core.action name="_bmuwJeE-EeOlhdB8eyQyLQ" org.eventb.core.assignment="process_wait_type(proc) ≔ wt" org.eventb.core.label="act43"/>
<org.eventb.core.action name="_gO9KweGGEeOlhdB8eyQyLQ" org.eventb.core.assignment="timeout_trigger ≔ timeout_trigger   tmout_trig" org.eventb.core.label="act05"/>
</org.eventb.core.event>
<org.eventb.core.event name="_m_Bs0uE4EeOlhdB8eyQyLQ" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="resource_become_available">
<org.eventb.core.refinesEvent name="_kyPaQOE6EeOlhdB8eyQyLQ" org.eventb.core.target="resource_become_available"/>
<org.eventb.core.parameter name="_CaEo4OGKEeOirusMDvDXUw" org.eventb.core.identifier="resch"/>
<org.eventb.core.guard name="_4vexgOFKEeOlhdB8eyQyLQ" org.eventb.core.label="grd40" org.eventb.core.predicate="process_wait_type(proc)= PROC_WAIT_OBJ"/>
<org.eventb.core.guard name="_CaFP8OGKEeOirusMDvDXUw" org.eventb.core.label="grd41" org.eventb.core.predicate="resch∈BOOL"/>
<org.eventb.core.action name="_yb2twOE-EeOlhdB8eyQyLQ" org.eventb.core.assignment="process_wait_type ≔  {proc}⩤process_wait_type" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_NUu-QOFLEeOlhdB8eyQyLQ" org.eventb.core.assignment="timeout_trigger ≔ {proc}⩤timeout_trigger" org.eventb.core.label="act42"/>
<org.eventb.core.action name="_6WD94OGDEeOlhdB8eyQyLQ" org.eventb.core.assignment="need_reschedule ≔ resch" org.eventb.core.label="act43"/>
</org.eventb.core.event>
<org.eventb.core.event name="_NXgU4OGMEeOirusMDvDXUw" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="resource_become_available2">
<org.eventb.core.refinesEvent name="_NXgU4eGMEeOirusMDvDXUw" org.eventb.core.target="resource_become_available2"/>
<org.eventb.core.parameter name="_NXg78OGMEeOirusMDvDXUw" org.eventb.core.identifier="resch"/>
<org.eventb.core.guard name="_NXg78eGMEeOirusMDvDXUw" org.eventb.core.label="grd40" org.eventb.core.predicate="∀proc·(proc∈procs ⇒ process_wait_type(proc)= PROC_WAIT_OBJ)"/>
<org.eventb.core.guard name="_NXg78uGMEeOirusMDvDXUw" org.eventb.core.label="grd41" org.eventb.core.predicate="resch∈BOOL"/>
<org.eventb.core.action name="_NXg78-GMEeOirusMDvDXUw" org.eventb.core.assignment="process_wait_type ≔  procs⩤process_wait_type" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_NXhjAOGMEeOirusMDvDXUw" org.eventb.core.assignment="timeout_trigger ≔ procs⩤timeout_trigger" org.eventb.core.label="act42"/>
<org.eventb.core.action name="_NXhjAeGMEeOirusMDvDXUw" org.eventb.core.assignment="need_reschedule ≔ resch" org.eventb.core.label="act43"/>
</org.eventb.core.event>
<org.eventb.core.event name="_m_Bs1OE4EeOlhdB8eyQyLQ" org.eventb.core.comment="has already finished execution of this period." org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="periodicproc_reach_releasepoint">
<org.eventb.core.refinesEvent name="_kyPaQeE6EeOlhdB8eyQyLQ" org.eventb.core.target="periodicproc_reach_releasepoint"/>
<org.eventb.core.guard name="_DkM2IOE8EeOlhdB8eyQyLQ" org.eventb.core.label="grd11" org.eventb.core.predicate="period_of_process(proc) ≠ INFINITE_TIME_VALUE"/>
<org.eventb.core.guard name="_DkM2IeE8EeOlhdB8eyQyLQ" org.eventb.core.label="grd12" org.eventb.core.predicate="clock_tick∗ONE_TICK_TIME ≥ releasepoint_of_process(proc)"/>
<org.eventb.core.guard name="_JzTjMCtrEeSCDLsjAFWqoQ" org.eventb.core.label="grd13" org.eventb.core.predicate="process_state(proc) = PS_Waiting"/>
<org.eventb.core.guard name="_JzTjMStrEeSCDLsjAFWqoQ" org.eventb.core.label="grd14" org.eventb.core.predicate="process_wait_type(proc) = PROC_WAIT_PERIOD"/>
<org.eventb.core.action name="_FdRSgDJ7EeSQ7c4olNszIw" org.eventb.core.assignment="releasepoint_of_process(proc) ≔  releasepoint_of_process(proc) + period_of_process(proc)" org.eventb.core.label="act41"/>
<org.eventb.core.action name="_Qq-EkDJ8EeSQ7c4olNszIw" org.eventb.core.assignment="deadlinetime_of_process(proc) ≔  releasepoint_of_process(proc) + timecapacity_of_process(proc)" org.eventb.core.label="act42"/>
</org.eventb.core.event>
<org.eventb.core.event name="_3C48kOE5EeOlhdB8eyQyLQ" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="coldstart_partition_fromidle">
<org.eventb.core.refinesEvent name="_xarzsDVIEeSxw-wt7-_VGQ" org.eventb.core.target="coldstart_partition_fromidle"/>
<org.eventb.core.action name="_jXF3oOFKEeOlhdB8eyQyLQ" org.eventb.core.assignment="locklevel_of_partition(part) ≔ 1" org.eventb.core.label="act401"/>
</org.eventb.core.event>
<org.eventb.core.event name="_3C48kuE5EeOlhdB8eyQyLQ" org.eventb.core.convergence="0" org.eventb.core.extended="true" org.eventb.core.label="warmstart_partition_fromidle">
<org.eventb.core.refinesEvent name="_xarzsTVIEeSxw-wt7-_VGQ" org.eventb.core.target="warmstart_partition_fromidle"/>
<org.eventb.core.action name="_jXPooOFKEeOlhdB8eyQyLQ" org.eventb.core.assignment="locklevel_of_partition(part) ≔ 1" org.eventb.core.label="act401"/>
</org.eventb.core.event>
</org.eventb.core.machineFile>
