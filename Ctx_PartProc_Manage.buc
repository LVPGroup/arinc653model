<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.contextFile org.eventb.core.comment="* ***************************************************&#10;The Event-B model of a verified partitioning kernel for safety-critical realtime systems&#10;Created by Yongwang Zhao ( zhaoyongwang@gmail.com)&#10;National Key Laboratory of Software Development Environment (NLSDE)&#10;School of Computer and Engineering, Beihang University, Beijing, China&#10;Date: 05/2014&#10;**************************************************/" org.eventb.core.configuration="org.eventb.core.fwd;de.prob.symbolic.ctxBase;de.prob.units.mchBase;org.eventb.codegen.ui.cgConfig;org.animb.valuation.valBase" org.eventb.texttools.text_lastmodified="1402187053791" org.eventb.texttools.text_representation="context Ctx_PartProc_Manage&#10;//* ***************************************************&#10;//   The Event-B model of a verified partitioning kernel for safety-critical realtime systems&#10;//   Created by Yongwang Zhao ( zhaoyongwang@gmail.com)&#10;//   National Key Laboratory of Software Development Environment (NLSDE)&#10;//   School of Computer and Engineering, Beihang University, Beijing, China&#10;//&#10;&#10;//   Date: 05/2014&#10;//   **************************************************/&#10;extends Ctx_PartProc_with_Events&#10;&#10;sets CRITILITY_LEVELS DEADLINE_TYPE PARTITION_STARTCONDITIONS PROCESS_WAIT_TYPES&#10;&#10;constants&#10;          Period_of_Partition&#10;          /* defines the activation period of the partition, and is used to determine the partition’s&#10;             runtime placement within the core module’s overall time frame. */&#10;          Duration_of_Partition // the amount of processor time given to the partition every period of the partition.&#10;          SystemPartFlag_of_Partition&#10;          //CriticalLevel_of_Partition&#10;          /* denotes criticality level of partition, Each partition is assigned a DO-178B criticality level from level A to E&#10;             EntryPoint&#10;             denotes partition elaboration restart address.&#10;             is a function name according to ARINC 653 SPEC */&#10;          //CRITILITY_LEVEL_A CRITILITY_LEVEL_B CRITILITY_LEVEL_C CRITILITY_LEVEL_D  CRITILITY_LEVEL_E // denotes criticality level of partition, Each partition is assigned a DO-178B criticality level from level A to E&#10;          NORMAL_START PARTITION_RESTART HM_MODULE_RESTART&#10;          HM_PARTITION_RESTART // reasons the partition is started&#10;&#10;          DEADLINE_HARD DEADLINE_SOFT&#10;          //APERIODIC_PROCESS_FLAG // the period value (0) of the aperiodic process, larger than 0 means the period of a periodic process&#10;&#10;          PROC_WAIT_DELAY PROC_WAIT_TIMEOUT PROC_WAIT_PERIOD PROC_WAIT_OBJ&#10;          PROC_WAIT_PARTITIONNORMAL //if a process is in WAITING state, the reasons of the WAITING, WAIT_OBJ means semaphore, event, etc.&#10;&#10;&#10;          partitionTimeWindows&#10;          timeWindowsofPartition&#10;          periodicprocstart_timeWindow_of_Partition //partition time windows with the periodic proc start is TRUE, of each partition&#10;          firstperiodicprocstart_timeWindow_of_Partition //partition time windows with the periodic proc start is TRUE, of each partition&#10;          majorFrame // the total time of all partitions&#10;&#10;          MAX_LOCK_LEVEL // max value of lock levels&#10;          MIN_PRIORITY_VALUE MAX_PRIORITY_VALUE&#10;          INFINITE_TIME_VALUE&#10;&#10;&#10;          ONE_TICK_TIME&#10;&#10;&#10;axioms&#10;  @axm_periodofpart Period_of_Partition ∈ PARTITIONS → ℕ&#10;  @axm_durationofpart Duration_of_Partition ∈ PARTITIONS → ℕ&#10;  @axm_syspart_flag SystemPartFlag_of_Partition ∈ PARTITIONS → BOOL&#10;  //@axm_criticallevel CriticalLevel_of_Partition ∈ PARTITIONS → CRITILITY_LEVELS&#10;  //@axm_partition_criticallevel partition(CRITILITY_LEVELS,{CRITILITY_LEVEL_A}, {CRITILITY_LEVEL_B}, {CRITILITY_LEVEL_C}, {CRITILITY_LEVEL_D},{CRITILITY_LEVEL_E})&#10;  @axm_partition_deadlinetype partition(DEADLINE_TYPE,{DEADLINE_HARD}, {DEADLINE_SOFT})&#10;  @axm_partition_startcondition partition(PARTITION_STARTCONDITIONS,{NORMAL_START}, {PARTITION_RESTART}, {HM_MODULE_RESTART}, {HM_PARTITION_RESTART})&#10;  @axm_partition_procwaittype partition(PROCESS_WAIT_TYPES,{PROC_WAIT_DELAY}, {PROC_WAIT_TIMEOUT}, {PROC_WAIT_PERIOD}, {PROC_WAIT_OBJ},{PROC_WAIT_PARTITIONNORMAL})&#10;  //@axm_aperiod_process_flag APERIODIC_PROCESS_FLAG = 0&#10;&#10;  @axm_parttimewin partitionTimeWindows ∈ (ℕ×ℕ)⇸BOOL    // each &lt;x |-&gt;y&gt;|-&gt;b : , x is the offset and y is the duration, b is the PeriodicProcessingStart flag&#10;  @axm_timewindowsofpar timeWindowsofPartition ∈ partitionTimeWindows ↠ PARTITIONS // total surjection: in a major frame, each partition should have one or more than one scheduling frame&#10;  @axm_majorframe majorFrame ∈ ℕ1 // majorFrame should be larger than sum of all schedulingframe. there may be spare time space between scheduling frames&#10;  @axm_perprocstart_tmwin periodicprocstart_timeWindow_of_Partition ∈ partitionTimeWindows ⤀ PARTITIONS&#10;  @axm_fstperprocstart_tmwin firstperiodicprocstart_timeWindow_of_Partition ∈ PARTITIONS↣partitionTimeWindows //total injection, each partition has the only one first periodic proc start window&#10;  //the next nine lines are commented by the reason that the arinc653 does not implement the scheduling and they are unsatisfiable in ProB&#10;  //@axm_parttimewin2 ∀x,y·(x ↦ y ∈ dom(partitionTimeWindows) ⇒ y &gt; 0) //duration of each partition time window is &gt; 0&#10;  //@axm_parttimewin3 ∀x1,y1,x2,y2·(x1 ↦ y1 ∈ dom(partitionTimeWindows) ∧ x2 ↦ y2 ∈ dom(partitionTimeWindows) ⇒ (x2 ≥ x1+y1 ∨ x1 ≥ x2+y2)) // partition time windows are disjoint */&#10;  //@axm_majorframe_value (∃x,y·(x ↦ y ∈ dom(partitionTimeWindows) ⇒ x+y=majorFrame)) ∧ (∀x,y·(x ↦ y ∈ dom(partitionTimeWindows) ⇒ x+y≤majorFrame))&#10;  //@axm_min_partwindow_eque_zero ∃x,y·(x ↦ y ∈ dom(partitionTimeWindows) ⇒ x=0)&#10;  //@axm_atleast_oneperiodicprocstart_for_eachpartition ∀p·(p∈PARTITIONS ⇒ (∃x,y·(((x↦y)↦TRUE)∈timeWindowsofPartition∼[{p}]))) //at least one partition time window of periodic proc start=TRUE, for each partition&#10;  //@axm_perprocstart_with_partwin (∀x,y,b,p·((x↦y↦b↦p)∈periodicprocstart_timeWindow_of_Partition ⇒ b=TRUE ∧ timeWindowsofPartition(x↦y↦b)=p))∧&#10;  //&#9;&#9;&#9;&#9;(∀x,y,b,p·((x↦y↦b↦p)∈timeWindowsofPartition ∧ b=TRUE ⇒ (x↦y↦b↦p)∈periodicprocstart_timeWindow_of_Partition)) //each&#10;  //@axm_fstperprocstart_tmwin2 ∀x,y,b,p·((p↦(x↦y↦b))∈firstperiodicprocstart_timeWindow_of_Partition⇒((x↦y↦b)↦p)∈ periodicprocstart_timeWindow_of_Partition)    //first periodic proc start window is one of periodic proc start window of a partition&#10;  //@axm_fstperprocstart_tmwin3 ∀x,y,b,p·((p↦(x↦y↦b))∈firstperiodicprocstart_timeWindow_of_Partition ⇒¬(∃x1,y1,b1,p1·(((x1↦y1↦b1)↦p1)∈periodicprocstart_timeWindow_of_Partition ∧ p=p1 ∧x1&lt;x))) //first periodic proc start window is the least one&#10;  //@axm_majorframe2 ∀x·(x∈ran(Period_of_Partition)⇒∃y·(y∈ℕ1 ∧ x ∗ y = majorFrame)) //Major frame: defined as a multiple of the least common multiple of all partition periods in the module.&#10;&#10;  @axm_maxvalue_locklevel MAX_LOCK_LEVEL = 32 // according to ARINC653&#10;  @axm_minpriorityvalue MIN_PRIORITY_VALUE = 0 // according to ARINC653&#10;  @axm_maxpriorityvalue MAX_PRIORITY_VALUE = 249 // according to ARINC653&#10;  @axm_inf_timevalue INFINITE_TIME_VALUE = −1 // according to ARINC653&#10;&#10;  @axm_oneticktime ONE_TICK_TIME = 20 // unit:ms. this is also the timer interrupt interval&#10;&#10;end&#10;" version="3">
<org.eventb.core.extendsContext name="_L0YfcNUOEeOE_q1ibjWlpA" org.eventb.core.target="Ctx_PartProc_with_Events"/>
<org.eventb.core.constant name="_0bED482fEeO_w8hSz1RRkQ" org.eventb.core.comment="defines the activation period of the partition, and is used to determine the partition’s&#10;             runtime placement within the core module’s overall time frame. " org.eventb.core.identifier="Period_of_Partition"/>
<org.eventb.core.constant name="_0bED5M2fEeO_w8hSz1RRkQ" org.eventb.core.comment="the amount of processor time given to the partition every period of the partition." org.eventb.core.identifier="Duration_of_Partition"/>
<org.eventb.core.constant name="_cxpToNJiEeOIk6vzYQGQiQ" org.eventb.core.comment="CriticalLevel_of_Partition&#10;denotes criticality level of partition, Each partition is assigned a DO-178B criticality level from level A to E&#10;             EntryPoint&#10;             denotes partition elaboration restart address.&#10;             is a function name according to ARINC 653 SPEC &#10;CRITILITY_LEVEL_A CRITILITY_LEVEL_B CRITILITY_LEVEL_C CRITILITY_LEVEL_D  CRITILITY_LEVEL_E // denotes criticality level of partition, Each partition is assigned a DO-178B criticality level from level A to E" org.eventb.core.identifier="SystemPartFlag_of_Partition"/>
<org.eventb.core.constant name="_0bED682fEeO_w8hSz1RRkQ" org.eventb.core.identifier="NORMAL_START"/>
<org.eventb.core.constant name="_0bED7M2fEeO_w8hSz1RRkQ" org.eventb.core.identifier="PARTITION_RESTART"/>
<org.eventb.core.constant name="_0bED7c2fEeO_w8hSz1RRkQ" org.eventb.core.identifier="HM_MODULE_RESTART"/>
<org.eventb.core.constant name="_0bED7s2fEeO_w8hSz1RRkQ" org.eventb.core.comment="reasons the partition is started" org.eventb.core.identifier="HM_PARTITION_RESTART"/>
<org.eventb.core.constant name="_0bED782fEeO_w8hSz1RRkQ" org.eventb.core.identifier="DEADLINE_HARD"/>
<org.eventb.core.constant name="_0bED8M2fEeO_w8hSz1RRkQ" org.eventb.core.comment="APERIODIC_PROCESS_FLAG // the period value (0) of the aperiodic process, larger than 0 means the period of a periodic process" org.eventb.core.identifier="DEADLINE_SOFT"/>
<org.eventb.core.constant name="_nPzH0NJSEeOIk6vzYQGQiQ" org.eventb.core.identifier="PROC_WAIT_DELAY"/>
<org.eventb.core.constant name="_nPzH0dJSEeOIk6vzYQGQiQ" org.eventb.core.identifier="PROC_WAIT_TIMEOUT"/>
<org.eventb.core.constant name="_nPzH0tJSEeOIk6vzYQGQiQ" org.eventb.core.identifier="PROC_WAIT_PERIOD"/>
<org.eventb.core.constant name="_nPzH09JSEeOIk6vzYQGQiQ" org.eventb.core.identifier="PROC_WAIT_OBJ"/>
<org.eventb.core.constant name="_dNtVMNK9EeOIk6vzYQGQiQ" org.eventb.core.comment="if a process is in WAITING state, the reasons of the WAITING, WAIT_OBJ means semaphore, event, etc." org.eventb.core.identifier="PROC_WAIT_PARTITIONNORMAL"/>
<org.eventb.core.constant name="_gSZFQNJcEeOIk6vzYQGQiQ" org.eventb.core.identifier="partitionTimeWindows"/>
<org.eventb.core.constant name="_XGo1cNJeEeOIk6vzYQGQiQ" org.eventb.core.identifier="timeWindowsofPartition"/>
<org.eventb.core.constant name="_vul4QNKCEeOIk6vzYQGQiQ" org.eventb.core.comment="partition time windows with the periodic proc start is TRUE, of each partition" org.eventb.core.identifier="periodicprocstart_timeWindow_of_Partition"/>
<org.eventb.core.constant name="_WmN0ENLOEeOIk6vzYQGQiQ" org.eventb.core.comment="partition time windows with the periodic proc start is TRUE, of each partition" org.eventb.core.identifier="firstperiodicprocstart_timeWindow_of_Partition"/>
<org.eventb.core.constant name="_0bED9M2fEeO_w8hSz1RRkQ" org.eventb.core.comment="the total time of all partitions" org.eventb.core.identifier="majorFrame"/>
<org.eventb.core.constant name="_0bED9c2fEeO_w8hSz1RRkQ" org.eventb.core.comment="max value of lock levels" org.eventb.core.identifier="MAX_LOCK_LEVEL"/>
<org.eventb.core.constant name="_0bED9s2fEeO_w8hSz1RRkQ" org.eventb.core.identifier="MIN_PRIORITY_VALUE"/>
<org.eventb.core.constant name="_0bED982fEeO_w8hSz1RRkQ" org.eventb.core.identifier="MAX_PRIORITY_VALUE"/>
<org.eventb.core.constant name="_0bED-M2fEeO_w8hSz1RRkQ" org.eventb.core.identifier="INFINITE_TIME_VALUE"/>
<org.eventb.core.axiom name="_0bED-c2fEeO_w8hSz1RRkQ" org.eventb.core.label="axm_periodofpart" org.eventb.core.predicate="Period_of_Partition ∈ PARTITIONS → ℕ"/>
<org.eventb.core.axiom name="_0bED-s2fEeO_w8hSz1RRkQ" org.eventb.core.label="axm_durationofpart" org.eventb.core.predicate="Duration_of_Partition ∈ PARTITIONS → ℕ"/>
<org.eventb.core.axiom name="_cxrv4NJiEeOIk6vzYQGQiQ" org.eventb.core.comment="@axm_criticallevel CriticalLevel_of_Partition ∈ PARTITIONS → CRITILITY_LEVELS&#10;@axm_partition_criticallevel partition(CRITILITY_LEVELS,{CRITILITY_LEVEL_A}, {CRITILITY_LEVEL_B}, {CRITILITY_LEVEL_C}, {CRITILITY_LEVEL_D},{CRITILITY_LEVEL_E})" org.eventb.core.label="axm_syspart_flag" org.eventb.core.predicate="SystemPartFlag_of_Partition ∈ PARTITIONS → BOOL"/>
<org.eventb.core.axiom name="_0bED_c2fEeO_w8hSz1RRkQ" org.eventb.core.label="axm_partition_deadlinetype" org.eventb.core.predicate="partition(DEADLINE_TYPE,{DEADLINE_HARD}, {DEADLINE_SOFT})"/>
<org.eventb.core.axiom name="_0bED_s2fEeO_w8hSz1RRkQ" org.eventb.core.label="axm_partition_startcondition" org.eventb.core.predicate="partition(PARTITION_STARTCONDITIONS,{NORMAL_START}, {PARTITION_RESTART}, {HM_MODULE_RESTART}, {HM_PARTITION_RESTART})"/>
<org.eventb.core.axiom name="_1RgIANJSEeOIk6vzYQGQiQ" org.eventb.core.comment="@axm_aperiod_process_flag APERIODIC_PROCESS_FLAG = 0" org.eventb.core.label="axm_partition_procwaittype" org.eventb.core.predicate="partition(PROCESS_WAIT_TYPES,{PROC_WAIT_DELAY}, {PROC_WAIT_TIMEOUT}, {PROC_WAIT_PERIOD}, {PROC_WAIT_OBJ},{PROC_WAIT_PARTITIONNORMAL})"/>
<org.eventb.core.axiom name="_gwvjQNJeEeOIk6vzYQGQiQ" org.eventb.core.comment="each &lt;x |-&gt;y&gt;|-&gt;b : , x is the offset and y is the duration, b is the PeriodicProcessingStart flag" org.eventb.core.label="axm_parttimewin" org.eventb.core.predicate="partitionTimeWindows ∈ (ℕ×ℕ)⇸BOOL"/>
<org.eventb.core.axiom name="_gwwKUNJeEeOIk6vzYQGQiQ" org.eventb.core.comment="total surjection: in a major frame, each partition should have one or more than one scheduling frame" org.eventb.core.label="axm_timewindowsofpar" org.eventb.core.predicate="timeWindowsofPartition ∈ partitionTimeWindows ↠ PARTITIONS"/>
<org.eventb.core.axiom name="_0bEEBM2fEeO_w8hSz1RRkQ" org.eventb.core.comment="majorFrame should be larger than sum of all schedulingframe. there may be spare time space between scheduling frames" org.eventb.core.label="axm_majorframe" org.eventb.core.predicate="majorFrame ∈ ℕ1"/>
<org.eventb.core.axiom name="_vupioNKCEeOIk6vzYQGQiQ" org.eventb.core.label="axm_perprocstart_tmwin" org.eventb.core.predicate="periodicprocstart_timeWindow_of_Partition ∈ partitionTimeWindows ⤀ PARTITIONS"/>
<org.eventb.core.axiom name="_WmSFgNLOEeOIk6vzYQGQiQ" org.eventb.core.comment="total injection, each partition has the only one first periodic proc start window&#10;the next nine lines are commented by the reason that the arinc653 does not implement the scheduling and they are unsatisfiable in ProB&#10;@axm_parttimewin2 ∀x,y·(x ↦ y ∈ dom(partitionTimeWindows) ⇒ y &gt; 0) //duration of each partition time window is &gt; 0&#10;@axm_parttimewin3 ∀x1,y1,x2,y2·(x1 ↦ y1 ∈ dom(partitionTimeWindows) ∧ x2 ↦ y2 ∈ dom(partitionTimeWindows) ⇒ (x2 ≥ x1+y1 ∨ x1 ≥ x2+y2)) // partition time windows are disjoint */&#10;@axm_majorframe_value (∃x,y·(x ↦ y ∈ dom(partitionTimeWindows) ⇒ x+y=majorFrame)) ∧ (∀x,y·(x ↦ y ∈ dom(partitionTimeWindows) ⇒ x+y≤majorFrame))&#10;@axm_min_partwindow_eque_zero ∃x,y·(x ↦ y ∈ dom(partitionTimeWindows) ⇒ x=0)&#10;@axm_atleast_oneperiodicprocstart_for_eachpartition ∀p·(p∈PARTITIONS ⇒ (∃x,y·(((x↦y)↦TRUE)∈timeWindowsofPartition∼[{p}]))) //at least one partition time window of periodic proc start=TRUE, for each partition&#10;@axm_perprocstart_with_partwin (∀x,y,b,p·((x↦y↦b↦p)∈periodicprocstart_timeWindow_of_Partition ⇒ b=TRUE ∧ timeWindowsofPartition(x↦y↦b)=p))∧&#10;&#9;&#9;&#9;&#9;(∀x,y,b,p·((x↦y↦b↦p)∈timeWindowsofPartition ∧ b=TRUE ⇒ (x↦y↦b↦p)∈periodicprocstart_timeWindow_of_Partition)) //each&#10;@axm_fstperprocstart_tmwin2 ∀x,y,b,p·((p↦(x↦y↦b))∈firstperiodicprocstart_timeWindow_of_Partition⇒((x↦y↦b)↦p)∈ periodicprocstart_timeWindow_of_Partition)    //first periodic proc start window is one of periodic proc start window of a partition&#10;@axm_fstperprocstart_tmwin3 ∀x,y,b,p·((p↦(x↦y↦b))∈firstperiodicprocstart_timeWindow_of_Partition ⇒¬(∃x1,y1,b1,p1·(((x1↦y1↦b1)↦p1)∈periodicprocstart_timeWindow_of_Partition ∧ p=p1 ∧x1&lt;x))) //first periodic proc start window is the least one&#10;@axm_majorframe2 ∀x·(x∈ran(Period_of_Partition)⇒∃y·(y∈ℕ1 ∧ x ∗ y = majorFrame)) //Major frame: defined as a multiple of the least common multiple of all partition periods in the module." org.eventb.core.label="axm_fstperprocstart_tmwin" org.eventb.core.predicate="firstperiodicprocstart_timeWindow_of_Partition ∈ PARTITIONS↣partitionTimeWindows"/>
<org.eventb.core.axiom name="_0bEEB82fEeO_w8hSz1RRkQ" org.eventb.core.comment="according to ARINC653" org.eventb.core.label="axm_maxvalue_locklevel" org.eventb.core.predicate="MAX_LOCK_LEVEL = 32"/>
<org.eventb.core.axiom name="_0bN04M2fEeO_w8hSz1RRkQ" org.eventb.core.comment="according to ARINC653" org.eventb.core.label="axm_minpriorityvalue" org.eventb.core.predicate="MIN_PRIORITY_VALUE = 0"/>
<org.eventb.core.axiom name="_0bN04c2fEeO_w8hSz1RRkQ" org.eventb.core.comment="according to ARINC653" org.eventb.core.label="axm_maxpriorityvalue" org.eventb.core.predicate="MAX_PRIORITY_VALUE = 249"/>
<org.eventb.core.axiom name="_0bN04s2fEeO_w8hSz1RRkQ" org.eventb.core.comment="according to ARINC653" org.eventb.core.label="axm_inf_timevalue" org.eventb.core.predicate="INFINITE_TIME_VALUE = −1"/>
<org.eventb.core.carrierSet name="_0bED4M2fEeO_w8hSz1RRkQ" org.eventb.core.identifier="CRITILITY_LEVELS"/>
<org.eventb.core.carrierSet name="_0bED4c2fEeO_w8hSz1RRkQ" org.eventb.core.identifier="DEADLINE_TYPE"/>
<org.eventb.core.carrierSet name="_0bED4s2fEeO_w8hSz1RRkQ" org.eventb.core.identifier="PARTITION_STARTCONDITIONS"/>
<org.eventb.core.carrierSet name="_1RkZcNJSEeOIk6vzYQGQiQ" org.eventb.core.identifier="PROCESS_WAIT_TYPES"/>
<org.eventb.core.constant name="_oAnYYNJgEeOIk6vzYQGQiQ" org.eventb.core.identifier="ONE_TICK_TIME"/>
<org.eventb.core.axiom name="_oAnYYdJgEeOIk6vzYQGQiQ" org.eventb.core.comment="unit:ms. this is also the timer interrupt interval" org.eventb.core.label="axm_oneticktime" org.eventb.core.predicate="ONE_TICK_TIME = 20"/>
</org.eventb.core.contextFile>
